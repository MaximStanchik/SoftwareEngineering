; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

	TITLE	D:\User\Desktop\Everythin' for BSTU\Narkevich\1-ый курс 2-ой семестр\Lab's\решения лбр\LBR_01\LBR_01\Debug\Exercise_1.obj
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

msvcjmc	SEGMENT
__CD417A16_concurrencysal@h DB 01H
__18C11F8D_sal@h DB 01H
__BD42D05E_vadefs@h DB 01H
__2DC9DF70_vcruntime@h DB 01H
__C9149A6D_xkeycheck@h DB 01H
__94F3B4AE_yvals_core@h DB 01H
__7B399007_limits@h DB 01H
__1AB9F2C2_climits DB 01H
__04C75F1C_corecrt@h DB 01H
__E81B5085_vcruntime_new@h DB 01H
__130137D5_vcruntime_new_debug@h DB 01H
__8CF369C8_crtdbg@h DB 01H
__95C621C9_crtdefs@h DB 01H
__FEED0ABF_use_ansi@h DB 01H
__2816668F_yvals@h DB 01H
__92857972_corecrt_math@h DB 01H
__A29DED85_math@h DB 01H
__494656A0_corecrt_malloc@h DB 01H
__0C5B3DCC_stddef@h DB 01H
__F1F53BCE_corecrt_search@h DB 01H
__DD5AA43A_corecrt_wstdlib@h DB 01H
__71F46169_stdlib@h DB 01H
__9E56D030_cstdlib DB 01H
__05E338F6_xtr1common DB 01H
__99FA516B_intrin0@inl@h DB 01H
__8CEB98C2_intrin0@h DB 01H
__7A7B113A_cmath DB 01H
__C44F8F6B_corecrt_stdio_config@h DB 01H
__A7F89B2B_corecrt_wstdio@h DB 01H
__B5C48800_stdio@h DB 01H
__A651C215_cstdio DB 01H
__15E49872_errno@h DB 01H
__6BB4896E_vcruntime_string@h DB 01H
__184F7456_corecrt_memcpy_s@h DB 01H
__82377222_corecrt_memory@h DB 01H
__5B29309E_corecrt_wstring@h DB 01H
__F787F5CD_string@h DB 01H
__D2C478D0_cstring DB 01H
__E387ED1C_corecrt_wconio@h DB 01H
__78D0C915_corecrt_wctype@h DB 01H
__02A4DD57_corecrt_wdirect@h DB 01H
__A056EFF3_corecrt_share@h DB 01H
__91FC0EDF_corecrt_wio@h DB 01H
__6619318A_corecrt_wprocess@h DB 01H
__18070508_corecrt_wtime@h DB 01H
__3D2AFB26_types@h DB 01H
__72103B05_stat@h DB 01H
__4BE26BFD_wchar@h DB 01H
__3CDA1446_cwchar DB 01H
__3B9D0A9D_cstddef DB 01H
__D7870C25_initializer_list DB 01H
__5E44C2A9_xstddef DB 01H
__7F1A9170_iosfwd DB 01H
__C54FBE38_stdint@h DB 01H
__2308314D_cstdint DB 01H
__87BD5CA6_type_traits DB 01H
__A95B55BB_utility DB 01H
__EE76B579___msvc_iter_core@hpp DB 01H
__A997C6C5_xutility DB 01H
__B83B7185_iterator DB 01H
__83BF90D8_share@h DB 01H
__9D384591___msvc_system_error_abi@hpp DB 01H
__3B70B6EE_cerrno DB 01H
__E5D9469F_malloc@h DB 01H
__C78E68C1_corecrt_terminate@h DB 01H
__510B0051_eh@h DB 01H
__1BEF3287_vcruntime_exception@h DB 01H
__5D994F5F_exception DB 01H
__CDB0EEF0_float@h DB 01H
__D5150992_cfloat DB 01H
__B83F831D_isa_availability@h DB 01H
__B3F344F6_limits DB 01H
__7E4C13A5_new DB 01H
__5795C389_xatomic@h DB 01H
__C3CE3678_xmemory DB 01H
__B71DB0E4_xstring DB 01H
__D4D77502_stdexcept DB 01H
__D76B6AFE_xcall_once@h DB 01H
__80837380_xerrc@h DB 01H
__93FD7E51_time@h DB 01H
__BCC88D32_ctime DB 01H
__1F532584_xtimec@h DB 01H
__9FA33D0C_xthreads@h DB 01H
__D8C61834_atomic DB 01H
__683678DE_system_error DB 01H
__FA9853E6_vcruntime_typeinfo@h DB 01H
__D94835DC_typeinfo DB 01H
__0F5D4878_memory DB 01H
__23181F77_xfacet DB 01H
__274043E2___msvc_xlocinfo_types@hpp DB 01H
__6AECDA3E_ctype@h DB 01H
__A99A25B2_cctype DB 01H
__66B29864_locale@h DB 01H
__0DFA0CE1_clocale DB 01H
__C6C1D614_xlocinfo DB 01H
__6823C4D5_xlocale DB 01H
__FF24A107_xiosbase DB 01H
__D677CDBE_streambuf DB 01H
__F6A4A2C2_xlocnum DB 01H
__868129B3_ios DB 01H
__7B331E11_ostream DB 01H
__18E32B2B_istream DB 01H
__CBEEBCDA_iostream DB 01H
__7B8ECEE4_string DB 01H
__456CA321_Time@h DB 01H
__A346771B_LeapOrNot@h DB 01H
__83299C4B_NumberOfDay@h DB 01H
__EE9DF070_stdafx@h DB 01H
__2CE65518_Exercise_1@cpp DB 01H
msvcjmc	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3
PUBLIC	?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3
PUBLIC	??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
PUBLIC	?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z	; std::_Narrow_char_traits<char,int>::length
PUBLIC	?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
PUBLIC	?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
PUBLIC	?eof@?$_Narrow_char_traits@DH@std@@SAHXZ	; std::_Narrow_char_traits<char,int>::eof
PUBLIC	?deallocate@?$allocator@D@std@@QAEXQADI@Z	; std::allocator<char>::deallocate
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
PUBLIC	_main
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
PUBLIC	??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
PUBLIC	??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z	; std::_Destroy_in_place<char *>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Deallocate@$07$0A@@std@@YAXPAXI@Z		; std::_Deallocate<8,0>
PUBLIC	??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
PUBLIC	?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	__JustMyCode_Default
PUBLIC	?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
PUBLIC	??_C@_0BB@FCMFBGOM@invalid?5argument@		; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs@				; `string'
PUBLIC	??_C@_0GC@ONGHGEHM@C?3?2Program?5Files?2Microsoft?5Visu@ ; `string'
PUBLIC	??_C@_1ME@DGNBIMPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ ; `string'
PUBLIC	??_C@_11LOCGONAA@@				; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ ; `string'
PUBLIC	??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@	; `string'
PUBLIC	??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ ; `string'
PUBLIC	??_C@_02FIDBHGA@ru@				; `string'
PUBLIC	??_C@_0CE@MLDGHCHJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?8?D?D?L?L?C?C?C@ ; `string'
PUBLIC	??_C@_0DF@GBNBKAPK@?M?e?b?e?p?m?n?e?5?j?n?k?h?w?e?q?r?b?n?5?d?$OA?m?m?$PL?u?5?h?k?h?5@ ; `string'
PUBLIC	??_C@_0DF@NLBOJDFJ@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0EK@IMLLBPBI@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0EI@KLKDCIPD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DE@PFIFBEOG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DF@NPKPHLGH@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DC@KGGDJCKF@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DD@LCIHLNIN@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DD@HODJBKEG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DG@CNDEPNCE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DH@FHAFLEFC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DG@JAFDHHDC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DF@IELJHFEE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DG@JHFIBEAD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ ; `string'
PUBLIC	??_C@_0DB@CEJLHCGC@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@ ; `string'
PUBLIC	??_C@_0DA@CIPDFLEI@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@ ; `string'
PUBLIC	??_C@_0DG@MNFJJKPE@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?c?n?d?0?5?$OA?5?h?l?e@ ; `string'
PUBLIC	??_C@_0BH@KNEJGAJJ@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?3?5@ ; `string'
PUBLIC	??_C@_0DG@MMHMHLB@?B?b?e?d?h?r?e?5?b?$OA?x?s?5?a?k?h?f?$OA?i?x?s?$PO?5?d?$OA?r?s?5?d?m?$PP@ ; `string'
PUBLIC	??_C@_05JAEFPJHO@?5?d?m?e?i@			; `string'
PUBLIC	??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@ ; `string'
PUBLIC	??_C@_0GH@ENIKJHNH@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@ ; `string'
PUBLIC	??_C@_0GM@PFCOCJKF@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@ ; `string'
PUBLIC	??_C@_0JE@ENKEGGAB@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@ ; `string'
PUBLIC	??_C@_0DA@KMMENEPG@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?d?$OA?r?s?4?5?A?s?d?$PM@ ; `string'
PUBLIC	??_C@_0FD@JINABHDA@?O?p?n?c?p?$OA?l?l?$OA?5?g?$OA?j?n?m?w?h?k?$OA?5?q?b?n?e?5?b?$PL?o?n?k?m@ ; `string'
PUBLIC	??_C@_05PDJBBECF@pause@				; `string'
PUBLIC	??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ ; `string'
PUBLIC	??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ ; `string'
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp___CrtDbgReport:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__exit:PROC
EXTRN	__imp__strtol:PROC
EXTRN	__imp__system:PROC
EXTRN	_strlen:PROC
EXTRN	?_Xinvalid_argument@std@@YAXPBD@Z:PROC		; std::_Xinvalid_argument
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?uncaught_exception@std@@YA_NXZ:PROC		; std::uncaught_exception
EXTRN	__imp__setlocale:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z:PROC
EXTRN	?currentDateTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:PROC ; currentDateTime
EXTRN	?leapOrNot@@YA_NH@Z:PROC			; leapOrNot
EXTRN	?NumberOfDay@@YAHHHHH@Z:PROC			; NumberOfDay
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__CheckForDebuggerJustMyCode@4:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	___security_cookie:DWORD
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
CONST	SEGMENT
??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@ DB '"'
	DB	00H, 'n', 00H, 'u', 00H, 'l', 00H, 'l', 00H, ' ', 00H, 'p', 00H
	DB	'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H, 'r', 00H, ' '
	DB	00H, 'c', 00H, 'a', 00H, 'n', 00H, 'n', 00H, 'o', 00H, 't', 00H
	DB	' ', 00H, 'p', 00H, 'o', 00H, 'i', 00H, 'n', 00H, 't', 00H, ' '
	DB	00H, 't', 00H, 'o', 00H, ' ', 00H, 'a', 00H, ' ', 00H, 'b', 00H
	DB	'l', 00H, 'o', 00H, 'c', 00H, 'k', 00H, ' ', 00H, 'o', 00H, 'f'
	DB	00H, ' ', 00H, 'n', 00H, 'o', 00H, 'n', 00H, '-', 00H, 'z', 00H
	DB	'e', 00H, 'r', 00H, 'o', 00H, ' ', 00H, 's', 00H, 'i', 00H, 'z'
	DB	00H, 'e', 00H, '"', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
CONST	SEGMENT
??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@ DB 'null pointe'
	DB	'r cannot point to a block of non-zero size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause@
CONST	SEGMENT
??_C@_05PDJBBECF@pause@ DB 'pause', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@JINABHDA@?O?p?n?c?p?$OA?l?l?$OA?5?g?$OA?j?n?m?w?h?k?$OA?5?q?b?n?e?5?b?$PL?o?n?k?m@
CONST	SEGMENT
??_C@_0FD@JINABHDA@?O?p?n?c?p?$OA?l?l?$OA?5?g?$OA?j?n?m?w?h?k?$OA?5?q?b?n?e?5?b?$PL?o?n?k?m@ DB 0cfH
	DB	0f0H, 0eeH, 0e3H, 0f0H, 0e0H, 0ecH, 0ecH, 0e0H, ' ', 0e7H, 0e0H
	DB	0eaH, 0eeH, 0edH, 0f7H, 0e8H, 0ebH, 0e0H, ' ', 0f1H, 0e2H, 0eeH
	DB	0e5H, ' ', 0e2H, 0fbH, 0efH, 0eeH, 0ebH, 0edH, 0e5H, 0edH, 0e8H
	DB	0e5H, '. ', 0c1H, 0ebH, 0e0H, 0e3H, 0eeH, 0e4H, 0e0H, 0f0H, 0e8H
	DB	0ecH, ' ', 0e7H, 0e0H, ' ', 0e8H, 0f1H, 0efH, 0eeH, 0ebH, 0fcH
	DB	0e7H, 0eeH, 0e2H, 0e0H, 0edH, 0e8H, 0e5H, ' ', 0edH, 0e0H, 0f8H
	DB	0e5H, 0e3H, 0eeH, ' ', 0efH, 0f0H, 0e8H, 0ebH, 0eeH, 0e6H, 0e5H
	DB	0edH, 0e8H, 0ffH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@KMMENEPG@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?d?$OA?r?s?4?5?A?s?d?$PM@
CONST	SEGMENT
??_C@_0DA@KMMENEPG@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?d?$OA?r?s?4?5?A?s?d?$PM@ DB 0c2H
	DB	0fbH, ' ', 0edH, 0e5H, 0efH, 0f0H, 0e0H, 0e2H, 0e8H, 0ebH, 0fcH
	DB	0edH, 0eeH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0e4H, 0e0H
	DB	0f2H, 0f3H, '. ', 0c1H, 0f3H, 0e4H, 0fcH, 0f2H, 0e5H, ' ', 0e2H
	DB	0edH, 0e8H, 0ecH, 0e0H, 0f2H, 0e5H, 0ebH, 0fcH, 0edH, 0e5H, 0e9H
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0JE@ENKEGGAB@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@
CONST	SEGMENT
??_C@_0JE@ENKEGGAB@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0edH, 0e5H, 0efH
	DB	0f0H, 0e0H, 0e2H, 0e8H, 0ebH, 0fcH, 0edH, 0eeH, ' ', 0e1H, 0ebH
	DB	0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0f3H, 0feH, ' ', 0e4H, 0e0H, 0f2H
	DB	0f3H, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ', '
	DB	0e0H, ' ', 0e8H, 0ecH, 0e5H, 0edH, 0edH, 0eeH, ': ', 0e1H, 0ebH
	DB	0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0e8H, 0e9H, ' ', 0e4H, 0e5H, 0edH
	DB	0fcH, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ' ', 0f7H
	DB	0e5H, 0f0H, 0e5H, 0e7H, ' ', 0edH, 0e5H, 0f1H, 0eaH, 0eeH, 0ebH
	DB	0fcH, 0eaH, 0eeH, ' ', 0ebH, 0e5H, 0f2H, '?! ', 0ceH, 0c3H, 0ceH
	DB	'! ', 0cdH, 0e5H, 0f2H, ', ', 0efH, 0eeH, 0e6H, 0e0H, 0ebH, 0f3H
	DB	0e9H, 0f1H, 0f2H, 0e0H, ', ', 0e2H, 0e2H, 0e5H, 0e4H, 0e8H, 0f2H
	DB	0e5H, ' ', 0e4H, 0e0H, 0f2H, 0f3H, ' ', 0efH, 0f0H, 0e0H, 0e2H
	DB	0e8H, 0ebH, 0fcH, 0edH, 0eeH, '.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GM@PFCOCJKF@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@
CONST	SEGMENT
??_C@_0GM@PFCOCJKF@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0edH, 0e5H, 0efH
	DB	0f0H, 0e0H, 0e2H, 0e8H, 0ebH, 0fcH, 0edH, 0eeH, ' ', 0e1H, 0ebH
	DB	0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0f3H, 0feH, ' ', 0e4H, 0e0H, 0f2H
	DB	0f3H, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ', '
	DB	0e0H, ' ', 0e8H, 0ecH, 0e5H, 0edH, 0edH, 0eeH, ': ', 0e3H, 0eeH
	DB	0e4H, ' ', 0e1H, 0ebH, 0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0e5H, 0e3H
	DB	0eeH, ' ', 0e4H, 0edH, 0ffH, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H
	DB	0edH, 0e8H, 0ffH, ' ', 0ecH, 0e5H, 0edH, 0fcH, 0f8H, 0e5H, ' ', 0f7H
	DB	0e5H, 0ecH, ' ', 0f2H, 0e5H, 0eaH, 0f3H, 0f9H, 0e8H, 0e9H, ' ', 0e3H
	DB	0eeH, 0e4H, '.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@ENIKJHNH@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@
CONST	SEGMENT
??_C@_0GH@ENIKJHNH@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0edH, 0e5H, 0efH
	DB	0f0H, 0e0H, 0e2H, 0e8H, 0ebH, 0fcH, 0edH, 0eeH, ' ', 0e1H, 0ebH
	DB	0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0f3H, 0feH, ' ', 0e4H, 0e0H, 0f2H
	DB	0f3H, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ', '
	DB	0e0H, ' ', 0e8H, 0ecH, 0e5H, 0edH, 0edH, 0eeH, ': ', 0c2H, 0e0H
	DB	0f8H, ' ', 0e1H, 0ebH, 0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0e8H, 0e9H
	DB	' ', 0e4H, 0e5H, 0edH, 0fcH, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H
	DB	0edH, 0e8H, 0ffH, ' ', 0e1H, 0f3H, 0e4H, 0e5H, 0f2H, ' ', 0e2H
	DB	' ', 0fdH, 0f2H, 0eeH, 0ecH, ' ', 0e3H, 0eeH, 0e4H, 0f3H, '.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@
CONST	SEGMENT
??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@ DB 0c4H
	DB	0eeH, ' ', 0e2H, 0e0H, 0f8H, 0e5H, 0e3H, 0eeH, ' ', 0e4H, 0edH
	DB	0ffH, ' ', 0f0H, 0eeH, 0e6H, 0e4H, 0e5H, 0edH, 0e8H, 0ffH, ' ', 0eeH
	DB	0f1H, 0f2H, 0e0H, 0ebH, 0eeH, 0f1H, 0fcH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05JAEFPJHO@?5?d?m?e?i@
CONST	SEGMENT
??_C@_05JAEFPJHO@?5?d?m?e?i@ DB ' ', 0e4H, 0edH, 0e5H, 0e9H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MMHMHLB@?B?b?e?d?h?r?e?5?b?$OA?x?s?5?a?k?h?f?$OA?i?x?s?$PO?5?d?$OA?r?s?5?d?m?$PP@
CONST	SEGMENT
??_C@_0DG@MMHMHLB@?B?b?e?d?h?r?e?5?b?$OA?x?s?5?a?k?h?f?$OA?i?x?s?$PO?5?d?$OA?r?s?5?d?m?$PP@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e2H, 0e0H, 0f8H, 0f3H
	DB	' ', 0e1H, 0ebH, 0e8H, 0e6H, 0e0H, 0e9H, 0f8H, 0f3H, 0feH, ' ', 0e4H
	DB	0e0H, 0f2H, 0f3H, ' ', 0e4H, 0edH, 0ffH, ' ', 0f0H, 0eeH, 0e6H
	DB	0e4H, 0e5H, 0edH, 0e8H, 0ffH, ' ''', 0c4H, 0c4H, 0ccH, 0ccH, 0c3H
	DB	0c3H, 0c3H, 0c3H, ''': ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@KNEJGAJJ@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?3?5@
CONST	SEGMENT
??_C@_0BH@KNEJGAJJ@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?3?5@ DB 0cfH
	DB	0eeH, 0f0H, 0ffH, 0e4H, 0eaH, 0eeH, 0e2H, 0fbH, 0e9H, ' ', 0edH
	DB	0eeH, 0ecH, 0e5H, 0f0H, ' ', 0e4H, 0edH, 0ffH, ': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@MNFJJKPE@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?c?n?d?0?5?$OA?5?h?l?e@
CONST	SEGMENT
??_C@_0DG@MNFJJKPE@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?c?n?d?0?5?$OA?5?h?l?e@ DB 0c2H
	DB	0fbH, ' ', 0edH, 0e5H, 0efH, 0f0H, 0e0H, 0e2H, 0e8H, 0ebH, 0fcH
	DB	0edH, 0eeH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0e3H, 0eeH
	DB	0e4H, ', ', 0e0H, ' ', 0e8H, 0ecH, 0e5H, 0edH, 0edH, 0eeH, ': '
	DB	0e3H, 0eeH, 0e4H, ' ', 0eeH, 0f2H, 0f0H, 0e8H, 0f6H, 0e0H, 0f2H
	DB	0e5H, 0ebH, 0fcH, 0edH, 0fbH, 0e9H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@CIPDFLEI@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@
CONST	SEGMENT
??_C@_0DA@CIPDFLEI@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@ DB 0cdH
	DB	0e5H, 0e2H, 0e5H, 0f0H, 0edH, 0fbH, 0e9H, ' ', 0f4H, 0eeH, 0f0H
	DB	0ecH, 0e0H, 0f2H, ' ', 0ecH, 0e5H, 0f1H, 0ffH, 0f6H, 0e0H, ', '
	DB	0e0H, ' ', 0e8H, 0ecH, 0e5H, 0edH, 0edH, 0eeH, ':', 0ecH, 0e5H
	DB	0f1H, 0ffH, 0f6H, ' ', 0ecH, 0e5H, 0edH, 0fcH, 0f8H, 0e5H, ' 1'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CEJLHCGC@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@
CONST	SEGMENT
??_C@_0DB@CEJLHCGC@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@ DB 0cdH
	DB	0e5H, 0e2H, 0e5H, 0f0H, 0edH, 0fbH, 0e9H, ' ', 0f4H, 0eeH, 0f0H
	DB	0ecH, 0e0H, 0f2H, ' ', 0ecH, 0e5H, 0f1H, 0ffH, 0f6H, 0e0H, ', '
	DB	0e0H, ' ', 0e8H, 0ecH, 0e5H, 0edH, 0edH, 0eeH, ':', 0ecH, 0e5H
	DB	0f1H, 0ffH, 0f6H, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0e5H, ' 1'
	DB	'2', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JHFIBEAD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DG@JHFIBEAD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0e4H, 0e5H, 0eaH, 0e0H, 0e1H, 0f0H, 0e5H, ' 31 ', 0e4H
	DB	0e5H, 0edH, 0fcH, ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@IELJHFEE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DF@IELJHFEE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0edH, 0eeH, 0ffH, 0e1H, 0f0H, 0e5H, ' 30 ', 0e4H, 0edH
	DB	0e5H, 0e9H, ')', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@JAFDHHDC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DG@JAFDHHDC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0eeH, 0eaH, 0f2H, 0ffH, 0e1H, 0f0H, 0e5H, ' 31 ', 0e4H
	DB	0e5H, 0edH, 0fcH, ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@FHAFLEFC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DH@FHAFLEFC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0f1H, 0e5H, 0edH, 0f2H, 0ffH, 0e1H, 0f0H, 0e5H, ' 3'
	DB	'0 ', 0e4H, 0edH, 0e5H, 0e9H, ')', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DG@CNDEPNCE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DG@CNDEPNCE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0e0H, 0e2H, 0e3H, 0f3H, 0f1H, 0f2H, 0e5H, ' 31 ', 0e4H
	DB	0e5H, 0edH, 0fcH, ')', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@HODJBKEG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DD@HODJBKEG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0e8H, 0feH, 0ebH, 0e5H, ' 31 ', 0e4H, 0e5H, 0edH, 0fcH
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@LCIHLNIN@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DD@LCIHLNIN@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0e8H, 0feH, 0edH, 0e5H, ' 30 ', 0e4H, 0edH, 0e5H, 0e9H
	DB	')', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@KGGDJCKF@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DC@KGGDJCKF@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0ecH, 0e0H, 0e5H, ' 31 ', 0e4H, 0e5H, 0edH, 0fcH, ')'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NPKPHLGH@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DF@NPKPHLGH@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0e0H, 0efH, 0f0H, 0e5H, 0ebH, 0e5H, ' 30 ', 0e4H, 0edH
	DB	0e5H, 0e9H, ')', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@PFIFBEOG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DE@PFIFBEOG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0ecH, 0e0H, 0f0H, 0f2H, 0e5H, ' 31 ', 0e4H, 0e5H, 0edH
	DB	0fcH, ')', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@KLKDCIPD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0EI@KLKDCIPD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0f4H, 0e5H, 0e2H, 0f0H, 0e0H, 0ebH, 0e5H, ' ', 0e2H
	DB	' ', 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH, 0eeH, 0ecH
	DB	' ', 0e3H, 0eeH, 0e4H, 0f3H, ' 29 ', 0e4H, 0edH, 0e5H, 0e9H, ')'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EK@IMLLBPBI@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0EK@IMLLBPBI@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0f4H, 0e5H, 0e2H, 0f0H, 0e0H, 0ebH, 0e5H, ' ', 0e2H
	DB	' ', 0edH, 0e5H, 0e2H, 0e8H, 0f1H, 0eeH, 0eaH, 0eeH, 0f1H, 0edH
	DB	0eeH, 0ecH, ' ', 0e3H, 0eeH, 0e4H, 0f3H, ' 28 ', 0e4H, 0edH, 0e5H
	DB	0e9H, ')', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@NLBOJDFJ@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
CONST	SEGMENT
??_C@_0DF@NLBOJDFJ@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@ DB 0c2H
	DB	0fbH, ' ', 0e2H, 0e2H, 0e5H, 0ebH, 0e8H, ' ', 0f1H, 0ebH, 0e8H
	DB	0f8H, 0eaH, 0eeH, 0ecH, ' ', 0e1H, 0eeH, 0ebH, 0fcH, 0f8H, 0eeH
	DB	0e5H, ' ', 0e7H, 0edH, 0e0H, 0f7H, 0e5H, 0edH, 0e8H, 0e5H, ' ('
	DB	0e2H, ' ', 0ffH, 0edH, 0e2H, 0e0H, 0f0H, 0e5H, ' 31 ', 0e4H, 0e5H
	DB	0edH, 0fcH, ')', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@GBNBKAPK@?M?e?b?e?p?m?n?e?5?j?n?k?h?w?e?q?r?b?n?5?d?$OA?m?m?$PL?u?5?h?k?h?5@
CONST	SEGMENT
??_C@_0DF@GBNBKAPK@?M?e?b?e?p?m?n?e?5?j?n?k?h?w?e?q?r?b?n?5?d?$OA?m?m?$PL?u?5?h?k?h?5@ DB 0cdH
	DB	0e5H, 0e2H, 0e5H, 0f0H, 0edH, 0eeH, 0e5H, ' ', 0eaH, 0eeH, 0ebH
	DB	0e8H, 0f7H, 0e5H, 0f1H, 0f2H, 0e2H, 0eeH, ' ', 0e4H, 0e0H, 0edH
	DB	0edH, 0fbH, 0f5H, ' ', 0e8H, 0ebH, 0e8H, ' ', 0e2H, ' ', 0e4H, 0e0H
	DB	0f2H, 0f3H, ' ', 0e2H, 0e2H, 0e5H, 0e4H, 0e5H, 0edH, 0edH, 0e0H
	DB	' ', 0f6H, 0e8H, 0f4H, 0f0H, 0e0H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@MLDGHCHJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?8?D?D?L?L?C?C?C@
CONST	SEGMENT
??_C@_0CE@MLDGHCHJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?8?D?D?L?L?C?C?C@ DB 0c2H
	DB	0e2H, 0e5H, 0e4H, 0e8H, 0f2H, 0e5H, ' ', 0e4H, 0e0H, 0f2H, 0f3H
	DB	' ', 0e2H, ' ', 0f4H, 0eeH, 0f0H, 0ecH, 0e0H, 0f2H, 0e5H, ' '''
	DB	0c4H, 0c4H, 0ccH, 0ccH, 0c3H, 0c3H, 0c3H, 0c3H, ''': ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02FIDBHGA@ru@
CONST	SEGMENT
??_C@_02FIDBHGA@ru@ DB 'ru', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
CONST	SEGMENT
??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@ DB 'stoi argument out '
	DB	'of range', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
CONST	SEGMENT
??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@ DB 'invalid stoi argument', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_11LOCGONAA@@
CONST	SEGMENT
??_C@_11LOCGONAA@@ DB 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1ME@DGNBIMPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
CONST	SEGMENT
??_C@_1ME@DGNBIMPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H
	DB	'r', 00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' '
	DB	00H, 'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H
	DB	' ', 00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o'
	DB	00H, '\', 00H, '2', 00H, '0', 00H, '2', 00H, '2', 00H, '\', 00H
	DB	'C', 00H, 'o', 00H, 'm', 00H, 'm', 00H, 'u', 00H, 'n', 00H, 'i'
	DB	00H, 't', 00H, 'y', 00H, '\', 00H, 'V', 00H, 'C', 00H, '\', 00H
	DB	'T', 00H, 'o', 00H, 'o', 00H, 'l', 00H, 's', 00H, '\', 00H, 'M'
	DB	00H, 'S', 00H, 'V', 00H, 'C', 00H, '\', 00H, '1', 00H, '4', 00H
	DB	'.', 00H, '3', 00H, '4', 00H, '.', 00H, '3', 00H, '1', 00H, '9'
	DB	00H, '3', 00H, '3', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'l', 00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm'
	DB	00H, 'e', 00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@ONGHGEHM@C?3?2Program?5Files?2Microsoft?5Visu@
CONST	SEGMENT
??_C@_0GC@ONGHGEHM@C?3?2Program?5Files?2Microsoft?5Visu@ DB 'C:\Program F'
	DB	'iles\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.'
	DB	'34.31933\include\xmemory', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs@ DB '%s', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FCMFBGOM@invalid?5argument@
CONST	SEGMENT
??_C@_0BB@FCMFBGOM@invalid?5argument@ DB 'invalid argument', 00H ; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA DD 091H ; `std::_Adjust_manually_vector_aligned'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	016H
	DB	023H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	034H
	DW	0477H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	019H
	DB	026H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	033H
	DW	0f2cH
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$_main DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_main$0
__ehfuncinfo$_main DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$_main
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	022H
	DB	0c2H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	09H
voltbl	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	090H
voltbl	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DB	024H
	DB	076H
voltbl	ENDS
; Function compile flags: /Odt
;	COMDAT __JustMyCode_Default
_TEXT	SEGMENT
__JustMyCode_Default PROC				; COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	5d		 pop	 ebp
  00004	c3		 ret	 0
__JustMyCode_Default ENDP
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z PROC ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 659  :     static _CONSTEXPR20 void deallocate(_Alloc& _Al, const pointer _Ptr, const size_type _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 660  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 661  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 662  :         if (_STD is_constant_evaluated()) {
; 663  :             _Al.deallocate(_Ptr, _Count);
; 664  :         } else
; 665  : #endif // _HAS_CXX20
; 666  :         {
; 667  :             (void) _Al;
; 668  :             _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);

  00021	8b 45 10	 mov	 eax, DWORD PTR __Count$[ebp]
  00024	c1 e0 03	 shl	 eax, 3
  00027	50		 push	 eax
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0002b	51		 push	 ecx
  0002c	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  00031	83 c4 08	 add	 esp, 8

; 669  :         }
; 670  :     }

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ENDP ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >, COMDAT

; 980  : _CONSTEXPR20 void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 981  :     // deallocate a plain pointer using an allocator
; 982  :     using _Alloc_traits = allocator_traits<_Alloc>;
; 983  :     if constexpr (is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>) {
; 984  :         _Alloc_traits::deallocate(_Al, _Ptr, 1);

  00041	6a 01		 push	 1
  00043	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00046	50		 push	 eax
  00047	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  0004a	51		 push	 ecx
  0004b	e8 00 00 00 00	 call	 ?deallocate@?$_Default_allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@2@QAU_Container_proxy@2@I@Z ; std::_Default_allocator_traits<std::allocator<std::_Container_proxy> >::deallocate
  00050	83 c4 0c	 add	 esp, 12			; 0000000cH

; 985  :     } else {
; 986  :         using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
; 987  :         _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
; 988  :     }
; 989  : }

  00053	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00056	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0005d	59		 pop	 ecx
  0005e	5f		 pop	 edi
  0005f	5e		 pop	 esi
  00060	5b		 pop	 ebx
  00061	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00067	3b ec		 cmp	 ebp, esp
  00069	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0006e	8b e5		 mov	 esp, ebp
  00070	5d		 pop	 ebp
  00071	c3		 ret	 0
  00072	cc		 int	 3
  00073	cc		 int	 3
  00074	cc		 int	 3
  00075	cc		 int	 3
  00076	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z PROC		; std::_Deallocate<8,0>, COMDAT

; 242  : _CONSTEXPR20 void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0001d	33 c9		 xor	 ecx, ecx
  0001f	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00024	f3 ab		 rep stosd
  00026	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  0002b	33 c5		 xor	 eax, ebp
  0002d	50		 push	 eax
  0002e	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00031	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00037	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  0003c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 243  :     // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align <= __STDCPP_DEFAULT_NEW_ALIGNMENT__
; 244  : #if _HAS_CXX20 // TRANSITION, GH-1532
; 245  :     if (_STD is_constant_evaluated()) {
; 246  :         ::operator delete(_Ptr);
; 247  :     } else
; 248  : #endif // _HAS_CXX20
; 249  :     {
; 250  : #if defined(_M_IX86) || defined(_M_X64)
; 251  :         if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

  00041	81 7d 0c 00 10
	00 00		 cmp	 DWORD PTR __Bytes$[ebp], 4096 ; 00001000H
  00048	72 10		 jb	 SHORT $LN2@Deallocate

; 252  :             _Adjust_manually_vector_aligned(_Ptr, _Bytes);

  0004a	8d 45 0c	 lea	 eax, DWORD PTR __Bytes$[ebp]
  0004d	50		 push	 eax
  0004e	8d 4d 08	 lea	 ecx, DWORD PTR __Ptr$[ebp]
  00051	51		 push	 ecx
  00052	e8 00 00 00 00	 call	 ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ; std::_Adjust_manually_vector_aligned
  00057	83 c4 08	 add	 esp, 8
$LN2@Deallocate:

; 253  :         }
; 254  : #endif // defined(_M_IX86) || defined(_M_X64)
; 255  :         ::operator delete(_Ptr, _Bytes);

  0005a	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  0005d	50		 push	 eax
  0005e	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  00061	51		 push	 ecx
  00062	e8 00 00 00 00	 call	 ??3@YAXPAXI@Z		; operator delete
  00067	83 c4 08	 add	 esp, 8

; 256  :     }
; 257  : }

  0006a	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0006d	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00074	59		 pop	 ecx
  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
  00089	cc		 int	 3
  0008a	cc		 int	 3
  0008b	cc		 int	 3
  0008c	cc		 int	 3
  0008d	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 30 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-208]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$_Deallocate@$07$0A@@std@@YAXPAXI@Z
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ENDP		; std::_Deallocate<8,0>
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 293  : _NODISCARD constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept { // do nothing for plain pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __5E44C2A9_xstddef
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 294  :     return _Ptr;

  00021	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]

; 295  : }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z
_TEXT	SEGMENT
__Obj$ = 8						; size = 4
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z PROC		; std::_Destroy_in_place<char *>, COMDAT

; 294  : _CONSTEXPR20 void _Destroy_in_place(_Ty& _Obj) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 295  :     if constexpr (is_array_v<_Ty>) {
; 296  :         _Destroy_range(_Obj, _Obj + extent_v<_Ty>);
; 297  :     } else {
; 298  :         _Obj.~_Ty();
; 299  :     }
; 300  : }

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ENDP		; std::_Destroy_in_place<char *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT
; _this$ = ecx

; 823  :     constexpr allocator(const allocator<_Other>&) noexcept {}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c2 04 00	 ret	 4
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z PROC ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >, COMDAT

; 992  : _CONSTEXPR20 void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 993  :     // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
; 994  :     using _Ty = typename _Alloc::value_type;
; 995  :     _Ptr->~_Ty();
; 996  :     _Deallocate_plain(_Al, _Ptr);

  00021	8b 45 0c	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00024	50		 push	 eax
  00025	8b 4d 08	 mov	 ecx, DWORD PTR __Al$[ebp]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ??$_Deallocate_plain@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Deallocate_plain<std::allocator<std::_Container_proxy> >
  0002e	83 c4 08	 add	 esp, 8

; 997  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003a	3b ec		 cmp	 ebp, esp
  0003c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00041	8b e5		 mov	 esp, ebp
  00043	5d		 pop	 ebp
  00044	c3		 ret	 0
??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ENDP ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 123  :         explicit __CLR_OR_THIS_CALL operator bool() const {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 124  :             return _Ok;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8a 40 04	 mov	 al, BYTE PTR [eax+4]

; 125  :         }

  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00039	3b ec		 cmp	 ebp, esp
  0003b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00040	8b e5		 mov	 esp, ebp
  00042	5d		 pop	 ebp
  00043	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -229						; size = 1
__Zero_uncaught_exceptions$ = -29			; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 108  :         __CLR_OR_THIS_CALL ~sentry() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 109  : #if !_HAS_EXCEPTIONS
; 110  :             const bool _Zero_uncaught_exceptions = true;
; 111  : #elif _HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 112  :             const bool _Zero_uncaught_exceptions = !_STD uncaught_exception(); // TRANSITION, ArchivedOS-12000909

  00049	e8 00 00 00 00	 call	 ?uncaught_exception@std@@YA_NXZ ; std::uncaught_exception
  0004e	0f b6 c0	 movzx	 eax, al
  00051	85 c0		 test	 eax, eax
  00053	75 09		 jne	 SHORT $LN4@sentry
  00055	c6 85 1b ff ff
	ff 01		 mov	 BYTE PTR tv72[ebp], 1
  0005c	eb 07		 jmp	 SHORT $LN5@sentry
$LN4@sentry:
  0005e	c6 85 1b ff ff
	ff 00		 mov	 BYTE PTR tv72[ebp], 0
$LN5@sentry:
  00065	8a 8d 1b ff ff
	ff		 mov	 cl, BYTE PTR tv72[ebp]
  0006b	88 4d e3	 mov	 BYTE PTR __Zero_uncaught_exceptions$[ebp], cl

; 113  : #else // ^^^ _HAS_DEPRECATED_UNCAUGHT_EXCEPTION / !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION vvv
; 114  :             const bool _Zero_uncaught_exceptions = _STD uncaught_exceptions() == 0;
; 115  : #endif // !_HAS_DEPRECATED_UNCAUGHT_EXCEPTION
; 116  : 
; 117  :             if (_Zero_uncaught_exceptions) {

  0006e	0f b6 45 e3	 movzx	 eax, BYTE PTR __Zero_uncaught_exceptions$[ebp]
  00072	85 c0		 test	 eax, eax
  00074	74 14		 je	 SHORT $LN1@sentry

; 118  :                 this->_Myostr._Osfx();

  00076	8b f4		 mov	 esi, esp
  00078	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0007b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0007d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
  00083	3b f4		 cmp	 esi, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@sentry:

; 119  :             }
; 120  :         }

  0008a	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  0008d	e8 00 00 00 00	 call	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00092	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00095	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009c	59		 pop	 ecx
  0009d	5f		 pop	 edi
  0009e	5e		 pop	 esi
  0009f	5b		 pop	 ebx
  000a0	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a6	3b ec		 cmp	 ebp, esp
  000a8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ad	8b e5		 mov	 esp, ebp
  000af	5d		 pop	 ebp
  000b0	c3		 ret	 0
  000b1	cc		 int	 3
  000b2	cc		 int	 3
  000b3	cc		 int	 3
  000b4	cc		 int	 3
  000b5	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Tied$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 91   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  0001e	b9 06 00 00 00	 mov	 ecx, 6
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00049	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0004c	50		 push	 eax
  0004d	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00050	e8 00 00 00 00	 call	 ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
  00055	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 92   :             if (!_Ostr.good()) {

  0005c	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0005f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00061	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00064	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00067	8b f4		 mov	 esi, esp
  00069	8b ca		 mov	 ecx, edx
  0006b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  00071	3b f4		 cmp	 esi, esp
  00073	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00078	0f b6 c0	 movzx	 eax, al
  0007b	85 c0		 test	 eax, eax
  0007d	75 09		 jne	 SHORT $LN2@sentry

; 93   :                 _Ok = false;

  0007f	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00082	c6 40 04 00	 mov	 BYTE PTR [eax+4], 0

; 94   :                 return;

  00086	eb 6a		 jmp	 SHORT $LN1@sentry
$LN2@sentry:

; 95   :             }
; 96   : 
; 97   :             const auto _Tied = _Ostr.tie();

  00088	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0008b	8b 08		 mov	 ecx, DWORD PTR [eax]
  0008d	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00090	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00093	8b f4		 mov	 esi, esp
  00095	8b ca		 mov	 ecx, edx
  00097	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a4	89 45 e0	 mov	 DWORD PTR __Tied$[ebp], eax

; 98   :             if (!_Tied || _Tied == &_Ostr) {

  000a7	83 7d e0 00	 cmp	 DWORD PTR __Tied$[ebp], 0
  000ab	74 08		 je	 SHORT $LN4@sentry
  000ad	8b 45 e0	 mov	 eax, DWORD PTR __Tied$[ebp]
  000b0	3b 45 08	 cmp	 eax, DWORD PTR __Ostr$[ebp]
  000b3	75 09		 jne	 SHORT $LN3@sentry
$LN4@sentry:

; 99   :                 _Ok = true;

  000b5	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000b8	c6 40 04 01	 mov	 BYTE PTR [eax+4], 1

; 100  :                 return;

  000bc	eb 34		 jmp	 SHORT $LN1@sentry
$LN3@sentry:

; 101  :             }
; 102  : 
; 103  :             _Tied->flush();

  000be	8b f4		 mov	 esi, esp
  000c0	8b 4d e0	 mov	 ecx, DWORD PTR __Tied$[ebp]
  000c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  000c9	3b f4		 cmp	 esi, esp
  000cb	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 104  :             _Ok = _Ostr.good(); // store test only after flushing tie

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000d8	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000db	8b f4		 mov	 esi, esp
  000dd	8b ca		 mov	 ecx, edx
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?good@ios_base@std@@QBE_NXZ
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ec	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  000ef	88 41 04	 mov	 BYTE PTR [ecx+4], al
$LN1@sentry:

; 105  :         }

  000f2	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000f9	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  000fc	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000ff	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00106	59		 pop	 ecx
  00107	5f		 pop	 edi
  00108	5e		 pop	 esi
  00109	5b		 pop	 ebx
  0010a	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  00110	3b ec		 cmp	 ebp, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	8b e5		 mov	 esp, ebp
  00119	5d		 pop	 ebp
  0011a	c2 04 00	 ret	 4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 18 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-232]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
  00028	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
tv72 = -232						; size = 4
__Rdbuf$ = -32						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 77   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d d8	 lea	 edi, DWORD PTR [ebp-40]
  0001e	b9 07 00 00 00	 mov	 ecx, 7
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 78   :             const auto _Rdbuf = _Myostr.rdbuf();

  00049	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0004e	89 8d 18 ff ff
	ff		 mov	 DWORD PTR tv72[ebp], ecx
  00054	8b 95 18 ff ff
	ff		 mov	 edx, DWORD PTR tv72[ebp]
  0005a	8b 02		 mov	 eax, DWORD PTR [edx]
  0005c	8b 8d 18 ff ff
	ff		 mov	 ecx, DWORD PTR tv72[ebp]
  00062	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  00065	8b f4		 mov	 esi, esp
  00067	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0006d	3b f4		 cmp	 esi, esp
  0006f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00074	89 45 e0	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 79   :             if (_Rdbuf) {

  00077	83 7d e0 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  0007b	74 16		 je	 SHORT $LN3@Sentry_bas

; 80   :                 _Rdbuf->_Unlock();

  0007d	8b 45 e0	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00080	8b 10		 mov	 edx, DWORD PTR [eax]
  00082	8b f4		 mov	 esi, esp
  00084	8b 4d e0	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00087	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0008a	ff d0		 call	 eax
  0008c	3b f4		 cmp	 esi, esp
  0008e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN3@Sentry_bas:

; 81   :             }
; 82   :         }

  00093	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00096	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  0009d	59		 pop	 ecx
  0009e	5f		 pop	 edi
  0009f	5e		 pop	 esi
  000a0	5b		 pop	 ebx
  000a1	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  000a7	3b ec		 cmp	 ebp, esp
  000a9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ae	8b e5		 mov	 esp, ebp
  000b0	5d		 pop	 ebp
  000b1	c3		 ret	 0
  000b2	cc		 int	 3
  000b3	cc		 int	 3
  000b4	cc		 int	 3
  000b5	cc		 int	 3
  000b6	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Rdbuf$ = -20						; size = 4
_this$ = -8						; size = 4
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 70   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00030	89 08		 mov	 DWORD PTR [eax], ecx

; 71   :             const auto _Rdbuf = _Myostr.rdbuf();

  00032	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 8d 24 ff ff
	ff		 mov	 DWORD PTR tv73[ebp], ecx
  0003d	8b 95 24 ff ff
	ff		 mov	 edx, DWORD PTR tv73[ebp]
  00043	8b 02		 mov	 eax, DWORD PTR [edx]
  00045	8b 8d 24 ff ff
	ff		 mov	 ecx, DWORD PTR tv73[ebp]
  0004b	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  0004e	8b f4		 mov	 esi, esp
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  00056	3b f4		 cmp	 esi, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	89 45 ec	 mov	 DWORD PTR __Rdbuf$[ebp], eax

; 72   :             if (_Rdbuf) {

  00060	83 7d ec 00	 cmp	 DWORD PTR __Rdbuf$[ebp], 0
  00064	74 16		 je	 SHORT $LN1@Sentry_bas

; 73   :                 _Rdbuf->_Lock();

  00066	8b 45 ec	 mov	 eax, DWORD PTR __Rdbuf$[ebp]
  00069	8b 10		 mov	 edx, DWORD PTR [eax]
  0006b	8b f4		 mov	 esi, esp
  0006d	8b 4d ec	 mov	 ecx, DWORD PTR __Rdbuf$[ebp]
  00070	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00073	ff d0		 call	 eax
  00075	3b f4		 cmp	 esi, esp
  00077	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN1@Sentry_bas:

; 74   :             }
; 75   :         }

  0007c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c2 04 00	 ret	 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 1005 :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1006 :     _Ostr.put(_Ostr.widen('\n'));

  00021	8b f4		 mov	 esi, esp
  00023	6a 0a		 push	 10			; 0000000aH
  00025	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0002d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00030	8b ca		 mov	 ecx, edx
  00032	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDD@Z
  00038	3b f4		 cmp	 esi, esp
  0003a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003f	8b f4		 mov	 esi, esp
  00041	0f b6 c0	 movzx	 eax, al
  00044	50		 push	 eax
  00045	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00048	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@D@Z
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1007 :     _Ostr.flush();

  00055	8b f4		 mov	 esi, esp
  00057	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0005a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
  00060	3b f4		 cmp	 esi, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1008 :     return _Ostr;

  00067	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]

; 1009 : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00073	3b ec		 cmp	 ebp, esp
  00075	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
tv135 = -356						; size = 8
tv343 = -348						; size = 8
tv291 = -344						; size = 4
tv288 = -344						; size = 8
tv286 = -344						; size = 4
tv329 = -340						; size = 8
tv290 = -340						; size = 4
tv285 = -340						; size = 4
tv287 = -336						; size = 4
tv137 = -336						; size = 4
tv289 = -333						; size = 1
tv284 = -333						; size = 1
$T2 = -328						; size = 4
$T3 = -316						; size = 4
$T4 = -304						; size = 4
$T5 = -292						; size = 4
$T6 = -280						; size = 4
__Ok$ = -76						; size = 8
__Pad$ = -60						; size = 8
__Count$ = -44						; size = 8
__State$ = -28						; size = 4
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
__Ostr$ = 8						; size = 4
__Val$ = 12						; size = 4
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 761  : basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	51		 push	 ecx
  00012	81 ec 54 01 00
	00		 sub	 esp, 340		; 00000154H
  00018	53		 push	 ebx
  00019	56		 push	 esi
  0001a	57		 push	 edi
  0001b	8d bd 5c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-164]
  00021	b9 25 00 00 00	 mov	 ecx, 37			; 00000025H
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00032	33 c5		 xor	 eax, ebp
  00034	89 45 ec	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00037	50		 push	 eax
  00038	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp+4]
  0003b	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00041	89 65 f0	 mov	 DWORD PTR __$EHRec$[ebp], esp
  00044	b9 00 00 00 00	 mov	 ecx, OFFSET __7B331E11_ostream
  00049	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 762  :     // insert NTBS into char stream
; 763  :     using _Elem = char;
; 764  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 765  : 
; 766  :     ios_base::iostate _State = ios_base::goodbit;

  0004e	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR __State$[ebp], 0

; 767  :     streamsize _Count        = static_cast<streamsize>(_Traits::length(_Val));

  00055	8b 45 0c	 mov	 eax, DWORD PTR __Val$[ebp]
  00058	50		 push	 eax
  00059	e8 00 00 00 00	 call	 ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ; std::_Narrow_char_traits<char,int>::length
  0005e	83 c4 04	 add	 esp, 4
  00061	33 c9		 xor	 ecx, ecx
  00063	89 45 d4	 mov	 DWORD PTR __Count$[ebp], eax
  00066	89 4d d8	 mov	 DWORD PTR __Count$[ebp+4], ecx

; 768  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

  00069	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0006c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00071	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00074	8b f4		 mov	 esi, esp
  00076	8b ca		 mov	 ecx, edx
  00078	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  0007e	3b f4		 cmp	 esi, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv329[ebp], eax
  0008b	89 95 b0 fe ff
	ff		 mov	 DWORD PTR tv329[ebp+4], edx
  00091	83 bd b0 fe ff
	ff 00		 cmp	 DWORD PTR tv329[ebp+4], 0
  00098	7c 79		 jl	 SHORT $LN17@operator
  0009a	7f 09		 jg	 SHORT $LN24@operator
  0009c	83 bd ac fe ff
	ff 00		 cmp	 DWORD PTR tv329[ebp], 0
  000a3	76 6e		 jbe	 SHORT $LN17@operator
$LN24@operator:
  000a5	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  000a8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000aa	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000ad	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  000b0	8b f4		 mov	 esi, esp
  000b2	8b ca		 mov	 ecx, edx
  000b4	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	89 85 a4 fe ff
	ff		 mov	 DWORD PTR tv343[ebp], eax
  000c7	89 95 a8 fe ff
	ff		 mov	 DWORD PTR tv343[ebp+4], edx
  000cd	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv343[ebp+4]
  000d3	3b 45 d8	 cmp	 eax, DWORD PTR __Count$[ebp+4]
  000d6	7c 3b		 jl	 SHORT $LN17@operator
  000d8	7f 0b		 jg	 SHORT $LN25@operator
  000da	8b 8d a4 fe ff
	ff		 mov	 ecx, DWORD PTR tv343[ebp]
  000e0	3b 4d d4	 cmp	 ecx, DWORD PTR __Count$[ebp]
  000e3	76 2e		 jbe	 SHORT $LN17@operator
$LN25@operator:
  000e5	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  000e8	8b 02		 mov	 eax, DWORD PTR [edx]
  000ea	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  000ed	03 48 04	 add	 ecx, DWORD PTR [eax+4]
  000f0	8b f4		 mov	 esi, esp
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QBE_JXZ
  000f8	3b f4		 cmp	 esi, esp
  000fa	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ff	2b 45 d4	 sub	 eax, DWORD PTR __Count$[ebp]
  00102	1b 55 d8	 sbb	 edx, DWORD PTR __Count$[ebp+4]
  00105	89 85 9c fe ff
	ff		 mov	 DWORD PTR tv135[ebp], eax
  0010b	89 95 a0 fe ff
	ff		 mov	 DWORD PTR tv135[ebp+4], edx
  00111	eb 0b		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00113	0f 57 c0	 xorps	 xmm0, xmm0
  00116	66 0f 13 85 9c
	fe ff ff	 movlpd	 QWORD PTR tv135[ebp], xmm0
$LN18@operator:
  0011e	8b 8d 9c fe ff
	ff		 mov	 ecx, DWORD PTR tv135[ebp]
  00124	8b 95 a0 fe ff
	ff		 mov	 edx, DWORD PTR tv135[ebp+4]
  0012a	89 4d c4	 mov	 DWORD PTR __Pad$[ebp], ecx
  0012d	89 55 c8	 mov	 DWORD PTR __Pad$[ebp+4], edx

; 769  :     const typename _Myos::sentry _Ok(_Ostr);

  00130	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00133	50		 push	 eax
  00134	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00137	e8 00 00 00 00	 call	 ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
  0013c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0

; 770  : 
; 771  :     if (!_Ok) {

  00143	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00146	e8 00 00 00 00	 call	 ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
  0014b	0f b6 c0	 movzx	 eax, al
  0014e	85 c0		 test	 eax, eax
  00150	75 0e		 jne	 SHORT $LN8@operator

; 772  :         _State |= ios_base::badbit;

  00152	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00155	83 c8 04	 or	 eax, 4
  00158	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 773  :     } else { // state okay, insert

  0015b	e9 ba 02 00 00	 jmp	 $LN9@operator
$LN8@operator:

; 774  :         _TRY_IO_BEGIN

  00160	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+12], 1

; 775  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

  00164	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00167	8b 08		 mov	 ecx, DWORD PTR [eax]
  00169	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0016c	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  0016f	8b f4		 mov	 esi, esp
  00171	8b ca		 mov	 ecx, edx
  00173	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?flags@ios_base@std@@QBEHXZ
  00179	3b f4		 cmp	 esi, esp
  0017b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00180	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv137[ebp], eax
  00186	8b 85 b0 fe ff
	ff		 mov	 eax, DWORD PTR tv137[ebp]
  0018c	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  00191	83 f8 40	 cmp	 eax, 64			; 00000040H
  00194	0f 84 d5 00 00
	00		 je	 $LN11@operator

; 776  :             for (; 0 < _Pad; --_Pad) { // pad on left

  0019a	eb 12		 jmp	 SHORT $LN4@operator
$LN2@operator:
  0019c	8b 45 c4	 mov	 eax, DWORD PTR __Pad$[ebp]
  0019f	83 e8 01	 sub	 eax, 1
  001a2	8b 4d c8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  001a5	83 d9 00	 sbb	 ecx, 0
  001a8	89 45 c4	 mov	 DWORD PTR __Pad$[ebp], eax
  001ab	89 4d c8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN4@operator:
  001ae	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  001b2	0f 8c b7 00 00
	00		 jl	 $LN11@operator
  001b8	7f 0a		 jg	 SHORT $LN26@operator
  001ba	83 7d c4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  001be	0f 86 ab 00 00
	00		 jbe	 $LN11@operator
$LN26@operator:

; 777  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  001c4	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001c7	8b 08		 mov	 ecx, DWORD PTR [eax]
  001c9	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001cc	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001cf	8b f4		 mov	 esi, esp
  001d1	8b ca		 mov	 ecx, edx
  001d3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  001d9	3b f4		 cmp	 esi, esp
  001db	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001e0	88 85 b3 fe ff
	ff		 mov	 BYTE PTR tv284[ebp], al
  001e6	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  001e9	8b 08		 mov	 ecx, DWORD PTR [eax]
  001eb	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  001ee	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  001f1	8b f4		 mov	 esi, esp
  001f3	8b ca		 mov	 ecx, edx
  001f5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  001fb	3b f4		 cmp	 esi, esp
  001fd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00202	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv285[ebp], eax
  00208	8b f4		 mov	 esi, esp
  0020a	0f b6 85 b3 fe
	ff ff		 movzx	 eax, BYTE PTR tv284[ebp]
  00211	50		 push	 eax
  00212	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv285[ebp]
  00218	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  0021e	3b f4		 cmp	 esi, esp
  00220	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00225	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv286[ebp], eax
  0022b	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv286[ebp]
  00231	89 8d e8 fe ff
	ff		 mov	 DWORD PTR $T6[ebp], ecx
  00237	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0023c	89 85 dc fe ff
	ff		 mov	 DWORD PTR $T5[ebp], eax
  00242	8d 95 e8 fe ff
	ff		 lea	 edx, DWORD PTR $T6[ebp]
  00248	52		 push	 edx
  00249	8d 85 dc fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  0024f	50		 push	 eax
  00250	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  00255	83 c4 08	 add	 esp, 8
  00258	0f b6 c8	 movzx	 ecx, al
  0025b	85 c9		 test	 ecx, ecx
  0025d	74 0b		 je	 SHORT $LN12@operator

; 778  :                     _State |= ios_base::badbit; // insertion failed, quit

  0025f	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00262	83 c8 04	 or	 eax, 4
  00265	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 779  :                     break;

  00268	eb 05		 jmp	 SHORT $LN11@operator
$LN12@operator:

; 780  :                 }
; 781  :             }

  0026a	e9 2d ff ff ff	 jmp	 $LN2@operator
$LN11@operator:

; 782  :         }
; 783  : 
; 784  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

  0026f	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  00273	75 6e		 jne	 SHORT $LN13@operator
  00275	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  00278	8b 08		 mov	 ecx, DWORD PTR [eax]
  0027a	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0027d	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00280	8b f4		 mov	 esi, esp
  00282	8b ca		 mov	 ecx, edx
  00284	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0028a	3b f4		 cmp	 esi, esp
  0028c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00291	89 85 b0 fe ff
	ff		 mov	 DWORD PTR tv287[ebp], eax
  00297	8b f4		 mov	 esi, esp
  00299	8b 45 d8	 mov	 eax, DWORD PTR __Count$[ebp+4]
  0029c	50		 push	 eax
  0029d	8b 4d d4	 mov	 ecx, DWORD PTR __Count$[ebp]
  002a0	51		 push	 ecx
  002a1	8b 55 0c	 mov	 edx, DWORD PTR __Val$[ebp]
  002a4	52		 push	 edx
  002a5	8b 8d b0 fe ff
	ff		 mov	 ecx, DWORD PTR tv287[ebp]
  002ab	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
  002b1	3b f4		 cmp	 esi, esp
  002b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  002b8	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv288[ebp], eax
  002be	89 95 ac fe ff
	ff		 mov	 DWORD PTR tv288[ebp+4], edx
  002c4	8b 85 a8 fe ff
	ff		 mov	 eax, DWORD PTR tv288[ebp]
  002ca	3b 45 d4	 cmp	 eax, DWORD PTR __Count$[ebp]
  002cd	75 0b		 jne	 SHORT $LN27@operator
  002cf	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv288[ebp+4]
  002d5	3b 4d d8	 cmp	 ecx, DWORD PTR __Count$[ebp+4]
  002d8	74 09		 je	 SHORT $LN13@operator
$LN27@operator:

; 785  :             _State |= ios_base::badbit;

  002da	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  002dd	83 c8 04	 or	 eax, 4
  002e0	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax
$LN13@operator:

; 786  :         }
; 787  : 
; 788  :         if (_State == ios_base::goodbit) {

  002e3	83 7d e4 00	 cmp	 DWORD PTR __State$[ebp], 0
  002e7	0f 85 d5 00 00
	00		 jne	 $LN14@operator

; 789  :             for (; 0 < _Pad; --_Pad) { // pad on right

  002ed	eb 12		 jmp	 SHORT $LN7@operator
$LN5@operator:
  002ef	8b 45 c4	 mov	 eax, DWORD PTR __Pad$[ebp]
  002f2	83 e8 01	 sub	 eax, 1
  002f5	8b 4d c8	 mov	 ecx, DWORD PTR __Pad$[ebp+4]
  002f8	83 d9 00	 sbb	 ecx, 0
  002fb	89 45 c4	 mov	 DWORD PTR __Pad$[ebp], eax
  002fe	89 4d c8	 mov	 DWORD PTR __Pad$[ebp+4], ecx
$LN7@operator:
  00301	83 7d c8 00	 cmp	 DWORD PTR __Pad$[ebp+4], 0
  00305	0f 8c b7 00 00
	00		 jl	 $LN14@operator
  0030b	7f 0a		 jg	 SHORT $LN28@operator
  0030d	83 7d c4 00	 cmp	 DWORD PTR __Pad$[ebp], 0
  00311	0f 86 ab 00 00
	00		 jbe	 $LN14@operator
$LN28@operator:

; 790  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

  00317	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0031a	8b 08		 mov	 ecx, DWORD PTR [eax]
  0031c	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  0031f	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00322	8b f4		 mov	 esi, esp
  00324	8b ca		 mov	 ecx, edx
  00326	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ
  0032c	3b f4		 cmp	 esi, esp
  0032e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00333	88 85 b3 fe ff
	ff		 mov	 BYTE PTR tv289[ebp], al
  00339	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0033c	8b 08		 mov	 ecx, DWORD PTR [eax]
  0033e	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  00341	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  00344	8b f4		 mov	 esi, esp
  00346	8b ca		 mov	 ecx, edx
  00348	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ
  0034e	3b f4		 cmp	 esi, esp
  00350	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00355	89 85 ac fe ff
	ff		 mov	 DWORD PTR tv290[ebp], eax
  0035b	8b f4		 mov	 esi, esp
  0035d	0f b6 85 b3 fe
	ff ff		 movzx	 eax, BYTE PTR tv289[ebp]
  00364	50		 push	 eax
  00365	8b 8d ac fe ff
	ff		 mov	 ecx, DWORD PTR tv290[ebp]
  0036b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
  00371	3b f4		 cmp	 esi, esp
  00373	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00378	89 85 a8 fe ff
	ff		 mov	 DWORD PTR tv291[ebp], eax
  0037e	8b 8d a8 fe ff
	ff		 mov	 ecx, DWORD PTR tv291[ebp]
  00384	89 8d d0 fe ff
	ff		 mov	 DWORD PTR $T4[ebp], ecx
  0038a	e8 00 00 00 00	 call	 ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ; std::_Narrow_char_traits<char,int>::eof
  0038f	89 85 c4 fe ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  00395	8d 95 d0 fe ff
	ff		 lea	 edx, DWORD PTR $T4[ebp]
  0039b	52		 push	 edx
  0039c	8d 85 c4 fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ; std::_Narrow_char_traits<char,int>::eq_int_type
  003a8	83 c4 08	 add	 esp, 8
  003ab	0f b6 c8	 movzx	 ecx, al
  003ae	85 c9		 test	 ecx, ecx
  003b0	74 0b		 je	 SHORT $LN15@operator

; 791  :                     _State |= ios_base::badbit; // insertion failed, quit

  003b2	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  003b5	83 c8 04	 or	 eax, 4
  003b8	89 45 e4	 mov	 DWORD PTR __State$[ebp], eax

; 792  :                     break;

  003bb	eb 05		 jmp	 SHORT $LN14@operator
$LN15@operator:

; 793  :                 }
; 794  :             }

  003bd	e9 2d ff ff ff	 jmp	 $LN5@operator
$LN14@operator:

; 795  :         }
; 796  : 
; 797  :         _Ostr.width(0);

  003c2	8b f4		 mov	 esi, esp
  003c4	6a 00		 push	 0
  003c6	6a 00		 push	 0
  003c8	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  003cd	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003d0	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003d3	8b ca		 mov	 ecx, edx
  003d5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?width@ios_base@std@@QAE_J_J@Z
  003db	3b f4		 cmp	 esi, esp
  003dd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  003e2	eb 26		 jmp	 SHORT $LN19@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 798  :         _CATCH_IO_(ios_base, _Ostr)

  003e4	8b f4		 mov	 esi, esp
  003e6	6a 01		 push	 1
  003e8	6a 04		 push	 4
  003ea	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  003ed	8b 08		 mov	 ecx, DWORD PTR [eax]
  003ef	8b 55 08	 mov	 edx, DWORD PTR __Ostr$[ebp]
  003f2	03 51 04	 add	 edx, DWORD PTR [ecx+4]
  003f5	8b ca		 mov	 ecx, edx
  003f7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  003fd	3b f4		 cmp	 esi, esp
  003ff	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00404	b8 00 00 00 00	 mov	 eax, $LN23@operator
  00409	c3		 ret	 0
$LN19@operator:
  0040a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
  00411	eb 07		 jmp	 SHORT $LN9@operator
$LN23@operator:
  00413	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+12], 0
$LN9@operator:

; 799  :     }
; 800  : 
; 801  :     _Ostr.setstate(_State);

  0041a	8b f4		 mov	 esi, esp
  0041c	6a 00		 push	 0
  0041e	8b 45 e4	 mov	 eax, DWORD PTR __State$[ebp]
  00421	50		 push	 eax
  00422	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  00425	8b 11		 mov	 edx, DWORD PTR [ecx]
  00427	8b 4d 08	 mov	 ecx, DWORD PTR __Ostr$[ebp]
  0042a	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  0042d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
  00433	3b f4		 cmp	 esi, esp
  00435	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 802  :     return _Ostr;

  0043a	8b 45 08	 mov	 eax, DWORD PTR __Ostr$[ebp]
  0043d	89 85 b8 fe ff
	ff		 mov	 DWORD PTR $T2[ebp], eax
  00443	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+12], -1
  0044a	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  0044d	e8 00 00 00 00	 call	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00452	8b 85 b8 fe ff
	ff		 mov	 eax, DWORD PTR $T2[ebp]

; 803  : }

  00458	52		 push	 edx
  00459	8b cd		 mov	 ecx, ebp
  0045b	50		 push	 eax
  0045c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN32@operator
  00462	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00467	58		 pop	 eax
  00468	5a		 pop	 edx
  00469	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp+4]
  0046c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00473	59		 pop	 ecx
  00474	5f		 pop	 edi
  00475	5e		 pop	 esi
  00476	5b		 pop	 ebx
  00477	8b 4d ec	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0047a	33 cd		 xor	 ecx, ebp
  0047c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00481	81 c4 64 01 00
	00		 add	 esp, 356		; 00000164H
  00487	3b ec		 cmp	 ebp, esp
  00489	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0048e	8b e5		 mov	 esp, ebp
  00490	5d		 pop	 ebp
  00491	c3		 ret	 0
  00492	66 90		 npad	 2
$LN32@operator:
  00494	01 00 00 00	 DD	 1
  00498	00 00 00 00	 DD	 $LN31@operator
$LN31@operator:
  0049c	b4 ff ff ff	 DD	 -76			; ffffffb4H
  004a0	08 00 00 00	 DD	 8
  004a4	00 00 00 00	 DD	 $LN29@operator
$LN29@operator:
  004a8	5f		 DB	 95			; 0000005fH
  004a9	4f		 DB	 79			; 0000004fH
  004aa	6b		 DB	 107			; 0000006bH
  004ab	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
  00000	8d 4d b4	 lea	 ecx, DWORD PTR __Ok$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
  00008	cc		 int	 3
  00009	cc		 int	 3
  0000a	cc		 int	 3
  0000b	cc		 int	 3
  0000c	cc		 int	 3
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
  0000d	90		 npad	 1
  0000e	90		 npad	 1
  0000f	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00013	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00016	8b 8a 98 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-360]
  0001c	33 c8		 xor	 ecx, eax
  0001e	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00023	8b 4a f8	 mov	 ecx, DWORD PTR [edx-8]
  00026	33 c8		 xor	 ecx, eax
  00028	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002d	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
  00032	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\User\Desktop\Everythin' for BSTU\Narkevich\1-ый курс 2-ой семестр\Lab's\решения лбр\LBR_01\LBR_01\Exercise_1.cpp
;	COMDAT _main
_TEXT	SEGMENT
tv534 = -464						; size = 4
tv535 = -460						; size = 4
$T2 = -452						; size = 28
_MOUNTH$ = -224						; size = 4
_Months$ = -212						; size = 48
_count$ = -156						; size = 4
_left$ = -144						; size = 4
_NumberOfcurrentDay$ = -132				; size = 4
_YearOfBirthday$ = -120					; size = 4
_Birthday$ = -108					; size = 4
_days$ = -96						; size = 4
_year$ = -72						; size = 4
_month$ = -60						; size = 4
_day$ = -48						; size = 4
_data$ = -36						; size = 4
_DATA$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_main	PROC						; COMDAT

; 12   : int main() {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_main
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec c4 01 00
	00		 sub	 esp, 452		; 000001c4H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd f0 fe ff
	ff		 lea	 edi, DWORD PTR [ebp-272]
  00020	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  00040	b9 00 00 00 00	 mov	 ecx, OFFSET __2CE65518_Exercise_1@cpp
  00045	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 13   : 	setlocale(LC_CTYPE, "ru");

  0004a	8b f4		 mov	 esi, esp
  0004c	68 00 00 00 00	 push	 OFFSET ??_C@_02FIDBHGA@ru@
  00051	6a 02		 push	 2
  00053	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__setlocale
  00059	83 c4 08	 add	 esp, 8
  0005c	3b f4		 cmp	 esi, esp
  0005e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 14   : 	int DATA = stoi(currentDateTime());

  00063	6a 0a		 push	 10			; 0000000aH
  00065	6a 00		 push	 0
  00067	8d 85 3c fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0006d	50		 push	 eax
  0006e	e8 00 00 00 00	 call	 ?currentDateTime@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; currentDateTime
  00073	83 c4 04	 add	 esp, 4
  00076	89 85 34 fe ff
	ff		 mov	 DWORD PTR tv535[ebp], eax
  0007c	8b 8d 34 fe ff
	ff		 mov	 ecx, DWORD PTR tv535[ebp]
  00082	89 8d 30 fe ff
	ff		 mov	 DWORD PTR tv534[ebp], ecx
  00088	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  0008f	8b 95 30 fe ff
	ff		 mov	 edx, DWORD PTR tv534[ebp]
  00095	52		 push	 edx
  00096	e8 00 00 00 00	 call	 ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ; std::stoi
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	89 45 e8	 mov	 DWORD PTR _DATA$[ebp], eax
  000a1	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000a8	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  000ae	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 15   : 	int data, day, month, year,A, days{}, Birthday, YearOfBirthday, NumberOfcurrentDay, left;

  000b3	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _days$[ebp], 0

; 16   : 	int count = 0;

  000ba	c7 85 64 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR _count$[ebp], 0

; 17   : 	int Months[12] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

  000c4	c7 85 2c ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp], 31 ; 0000001fH
  000ce	c7 85 30 ff ff
	ff 1c 00 00 00	 mov	 DWORD PTR _Months$[ebp+4], 28 ; 0000001cH
  000d8	c7 85 34 ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp+8], 31 ; 0000001fH
  000e2	c7 85 38 ff ff
	ff 1e 00 00 00	 mov	 DWORD PTR _Months$[ebp+12], 30 ; 0000001eH
  000ec	c7 85 3c ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp+16], 31 ; 0000001fH
  000f6	c7 85 40 ff ff
	ff 1e 00 00 00	 mov	 DWORD PTR _Months$[ebp+20], 30 ; 0000001eH
  00100	c7 85 44 ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp+24], 31 ; 0000001fH
  0010a	c7 85 48 ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp+28], 31 ; 0000001fH
  00114	c7 85 4c ff ff
	ff 1e 00 00 00	 mov	 DWORD PTR _Months$[ebp+32], 30 ; 0000001eH
  0011e	c7 85 50 ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp+36], 31 ; 0000001fH
  00128	c7 85 54 ff ff
	ff 1e 00 00 00	 mov	 DWORD PTR _Months$[ebp+40], 30 ; 0000001eH
  00132	c7 85 58 ff ff
	ff 1f 00 00 00	 mov	 DWORD PTR _Months$[ebp+44], 31 ; 0000001fH

; 18   : 	cout << "Введите дату в формате 'ДДММГГГГ': ";

  0013c	68 00 00 00 00	 push	 OFFSET ??_C@_0CE@MLDGHCHJ@?B?b?e?d?h?r?e?5?d?$OA?r?s?5?b?5?t?n?p?l?$OA?r?e?5?8?D?D?L?L?C?C?C@
  00141	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00146	50		 push	 eax
  00147	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0014c	83 c4 08	 add	 esp, 8

; 19   : 	cin >> data;

  0014f	8b f4		 mov	 esi, esp
  00151	8d 45 dc	 lea	 eax, DWORD PTR _data$[ebp]
  00154	50		 push	 eax
  00155	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0015b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
  00161	3b f4		 cmp	 esi, esp
  00163	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 20   : 
; 21   : 	day = data / 1000000; //потому что переменная содержит восемь цифр и шесть цифр у нас отсекается у даты. получаем просто день. 

  00168	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  0016b	99		 cdq
  0016c	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00171	f7 f9		 idiv	 ecx
  00173	89 45 d0	 mov	 DWORD PTR _day$[ebp], eax

; 22   : 	month = (data % 1000000) / 10000;

  00176	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  00179	99		 cdq
  0017a	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0017f	f7 f9		 idiv	 ecx
  00181	8b c2		 mov	 eax, edx
  00183	99		 cdq
  00184	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00189	f7 f9		 idiv	 ecx
  0018b	89 45 c4	 mov	 DWORD PTR _month$[ebp], eax

; 23   : 	year = data % 10000;

  0018e	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  00191	99		 cdq
  00192	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00197	f7 f9		 idiv	 ecx
  00199	89 55 b8	 mov	 DWORD PTR _year$[ebp], edx
$LN2@main:

; 24   : 
; 25   : 	
; 26   : 
; 27   : 	//тут цикл считает правильное кол-ко цифр вписано или нет. Если их мало или слишком много программа закрывается.
; 28   : 
; 29   : 	while (data > 0) {

  0019c	83 7d dc 00	 cmp	 DWORD PTR _data$[ebp], 0
  001a0	7e 1f		 jle	 SHORT $LN3@main

; 30   : 		data /= 10; // /= значит разделить переменную на значение и ответ присвоить этой же переменной

  001a2	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  001a5	99		 cdq
  001a6	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  001ab	f7 f9		 idiv	 ecx
  001ad	89 45 dc	 mov	 DWORD PTR _data$[ebp], eax

; 31   : 		count++;

  001b0	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  001b6	83 c0 01	 add	 eax, 1
  001b9	89 85 64 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 32   : 	}

  001bf	eb db		 jmp	 SHORT $LN2@main
$LN3@main:

; 33   : 	if (count < 7 && count > 8) {

  001c1	83 bd 64 ff ff
	ff 07		 cmp	 DWORD PTR _count$[ebp], 7
  001c8	7d 2d		 jge	 SHORT $LN6@main
  001ca	83 bd 64 ff ff
	ff 08		 cmp	 DWORD PTR _count$[ebp], 8
  001d1	7e 24		 jle	 SHORT $LN6@main

; 34   : 		cout << "Неверное количество данных или в дату введенна цифра";

  001d3	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GBNBKAPK@?M?e?b?e?p?m?n?e?5?j?n?k?h?w?e?q?r?b?n?5?d?$OA?m?m?$PL?u?5?h?k?h?5@
  001d8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001dd	50		 push	 eax
  001de	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  001e3	83 c4 08	 add	 esp, 8

; 35   : 		exit(0);

  001e6	8b f4		 mov	 esi, esp
  001e8	6a 00		 push	 0
  001ea	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  001f0	3b f4		 cmp	 esi, esp
  001f2	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN6@main:

; 36   : 	}
; 37   : 
; 38   : 	//Тут определяем правильно ли введен день
; 39   : 
; 40   : 	if (month == 01 && day > 31) {

  001f7	83 7d c4 01	 cmp	 DWORD PTR _month$[ebp], 1
  001fb	75 36		 jne	 SHORT $LN7@main
  001fd	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  00201	7e 30		 jle	 SHORT $LN7@main

; 41   : 		cout << "Вы ввели слишком большое значение (в январе 31 день)" << endl;

  00203	8b f4		 mov	 esi, esp
  00205	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0020a	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NLBOJDFJ@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  0020f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00214	50		 push	 eax
  00215	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0021a	83 c4 08	 add	 esp, 8
  0021d	8b c8		 mov	 ecx, eax
  0021f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00225	3b f4		 cmp	 esi, esp
  00227	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 42   : 		return 0;

  0022c	33 c0		 xor	 eax, eax
  0022e	e9 da 0c 00 00	 jmp	 $LN56@main
$LN7@main:

; 43   : 	}
; 44   : 	if (month == 02 && year % 4 != 0 && day > 28) {

  00233	83 7d c4 02	 cmp	 DWORD PTR _month$[ebp], 2
  00237	75 49		 jne	 SHORT $LN8@main
  00239	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  0023c	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00241	79 05		 jns	 SHORT $LN63@main
  00243	48		 dec	 eax
  00244	83 c8 fc	 or	 eax, -4			; fffffffcH
  00247	40		 inc	 eax
$LN63@main:
  00248	85 c0		 test	 eax, eax
  0024a	74 36		 je	 SHORT $LN8@main
  0024c	83 7d d0 1c	 cmp	 DWORD PTR _day$[ebp], 28 ; 0000001cH
  00250	7e 30		 jle	 SHORT $LN8@main

; 45   : 		cout << "Вы ввели слишком большое значение (в феврале в невисокосном году 28 дней)" << endl;

  00252	8b f4		 mov	 esi, esp
  00254	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00259	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@IMLLBPBI@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  0025e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00263	50		 push	 eax
  00264	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00269	83 c4 08	 add	 esp, 8
  0026c	8b c8		 mov	 ecx, eax
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00274	3b f4		 cmp	 esi, esp
  00276	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 46   : 		return 0;

  0027b	33 c0		 xor	 eax, eax
  0027d	e9 8b 0c 00 00	 jmp	 $LN56@main
$LN8@main:

; 47   : 	}
; 48   : 	if (month == 02 && year % 4 == 0 && day > 29) {

  00282	83 7d c4 02	 cmp	 DWORD PTR _month$[ebp], 2
  00286	75 49		 jne	 SHORT $LN9@main
  00288	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  0028b	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00290	79 05		 jns	 SHORT $LN64@main
  00292	48		 dec	 eax
  00293	83 c8 fc	 or	 eax, -4			; fffffffcH
  00296	40		 inc	 eax
$LN64@main:
  00297	85 c0		 test	 eax, eax
  00299	75 36		 jne	 SHORT $LN9@main
  0029b	83 7d d0 1d	 cmp	 DWORD PTR _day$[ebp], 29 ; 0000001dH
  0029f	7e 30		 jle	 SHORT $LN9@main

; 49   : 		cout << "Вы ввели слишком большое значение (в феврале в високосном году 29 дней)" << endl;

  002a1	8b f4		 mov	 esi, esp
  002a3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002a8	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@KLKDCIPD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  002ad	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002b2	50		 push	 eax
  002b3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002b8	83 c4 08	 add	 esp, 8
  002bb	8b c8		 mov	 ecx, eax
  002bd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002c3	3b f4		 cmp	 esi, esp
  002c5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 50   : 		return 0;

  002ca	33 c0		 xor	 eax, eax
  002cc	e9 3c 0c 00 00	 jmp	 $LN56@main
$LN9@main:

; 51   : 	}
; 52   : 	if (month == 03 && day > 31) {

  002d1	83 7d c4 03	 cmp	 DWORD PTR _month$[ebp], 3
  002d5	75 36		 jne	 SHORT $LN10@main
  002d7	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  002db	7e 30		 jle	 SHORT $LN10@main

; 53   : 		cout << "Вы ввели слишком большое значение (в марте 31 день)" << endl;

  002dd	8b f4		 mov	 esi, esp
  002df	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  002e4	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PFIFBEOG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  002e9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002ee	50		 push	 eax
  002ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  002f4	83 c4 08	 add	 esp, 8
  002f7	8b c8		 mov	 ecx, eax
  002f9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  002ff	3b f4		 cmp	 esi, esp
  00301	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 54   : 		return 0;

  00306	33 c0		 xor	 eax, eax
  00308	e9 00 0c 00 00	 jmp	 $LN56@main
$LN10@main:

; 55   : 	}
; 56   : 	if (month == 04 && day > 30) {

  0030d	83 7d c4 04	 cmp	 DWORD PTR _month$[ebp], 4
  00311	75 36		 jne	 SHORT $LN11@main
  00313	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  00317	7e 30		 jle	 SHORT $LN11@main

; 57   : 		cout << "Вы ввели слишком большое значение (в апреле 30 дней)" << endl;

  00319	8b f4		 mov	 esi, esp
  0031b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00320	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NPKPHLGH@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00325	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0032a	50		 push	 eax
  0032b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00330	83 c4 08	 add	 esp, 8
  00333	8b c8		 mov	 ecx, eax
  00335	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0033b	3b f4		 cmp	 esi, esp
  0033d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 58   : 		return 0;

  00342	33 c0		 xor	 eax, eax
  00344	e9 c4 0b 00 00	 jmp	 $LN56@main
$LN11@main:

; 59   : 	}
; 60   : 	if (month == 05 && day > 31) {

  00349	83 7d c4 05	 cmp	 DWORD PTR _month$[ebp], 5
  0034d	75 36		 jne	 SHORT $LN12@main
  0034f	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  00353	7e 30		 jle	 SHORT $LN12@main

; 61   : 		cout << "Вы ввели слишком большое значение (в мае 31 день)" << endl;

  00355	8b f4		 mov	 esi, esp
  00357	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0035c	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KGGDJCKF@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00361	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00366	50		 push	 eax
  00367	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0036c	83 c4 08	 add	 esp, 8
  0036f	8b c8		 mov	 ecx, eax
  00371	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00377	3b f4		 cmp	 esi, esp
  00379	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 62   : 		return 0;

  0037e	33 c0		 xor	 eax, eax
  00380	e9 88 0b 00 00	 jmp	 $LN56@main
$LN12@main:

; 63   : 	}
; 64   : 	if (month == 06 && day > 30) {

  00385	83 7d c4 06	 cmp	 DWORD PTR _month$[ebp], 6
  00389	75 36		 jne	 SHORT $LN13@main
  0038b	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  0038f	7e 30		 jle	 SHORT $LN13@main

; 65   : 		cout << "Вы ввели слишком большое значение (в июне 30 дней)" << endl;

  00391	8b f4		 mov	 esi, esp
  00393	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00398	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@LCIHLNIN@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  0039d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003a2	50		 push	 eax
  003a3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003a8	83 c4 08	 add	 esp, 8
  003ab	8b c8		 mov	 ecx, eax
  003ad	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  003b3	3b f4		 cmp	 esi, esp
  003b5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 66   : 		return 0;

  003ba	33 c0		 xor	 eax, eax
  003bc	e9 4c 0b 00 00	 jmp	 $LN56@main
$LN13@main:

; 67   : 	}
; 68   : 	if (month == 07 && day > 31) {

  003c1	83 7d c4 07	 cmp	 DWORD PTR _month$[ebp], 7
  003c5	75 36		 jne	 SHORT $LN14@main
  003c7	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  003cb	7e 30		 jle	 SHORT $LN14@main

; 69   : 		cout << "Вы ввели слишком большое значение (в июле 31 день)" << endl;

  003cd	8b f4		 mov	 esi, esp
  003cf	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  003d4	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@HODJBKEG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  003d9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003de	50		 push	 eax
  003df	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  003e4	83 c4 08	 add	 esp, 8
  003e7	8b c8		 mov	 ecx, eax
  003e9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  003ef	3b f4		 cmp	 esi, esp
  003f1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 70   : 		return 0;

  003f6	33 c0		 xor	 eax, eax
  003f8	e9 10 0b 00 00	 jmp	 $LN56@main
$LN14@main:

; 71   : 	}
; 72   : 	if (month == 8 && day > 31) {

  003fd	83 7d c4 08	 cmp	 DWORD PTR _month$[ebp], 8
  00401	75 36		 jne	 SHORT $LN15@main
  00403	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  00407	7e 30		 jle	 SHORT $LN15@main

; 73   : 		cout << "Вы ввели слишком большое значение (в августе 31 день)" << endl;

  00409	8b f4		 mov	 esi, esp
  0040b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00410	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@CNDEPNCE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00415	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0041a	50		 push	 eax
  0041b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00420	83 c4 08	 add	 esp, 8
  00423	8b c8		 mov	 ecx, eax
  00425	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0042b	3b f4		 cmp	 esi, esp
  0042d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 74   : 		return 0;

  00432	33 c0		 xor	 eax, eax
  00434	e9 d4 0a 00 00	 jmp	 $LN56@main
$LN15@main:

; 75   : 	}
; 76   : 	if (month == 9 && day > 30) {

  00439	83 7d c4 09	 cmp	 DWORD PTR _month$[ebp], 9
  0043d	75 36		 jne	 SHORT $LN16@main
  0043f	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  00443	7e 30		 jle	 SHORT $LN16@main

; 77   : 		cout << "Вы ввели слишком большое значение (в сентябре 30 дней)" << endl;

  00445	8b f4		 mov	 esi, esp
  00447	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0044c	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@FHAFLEFC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00451	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00456	50		 push	 eax
  00457	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0045c	83 c4 08	 add	 esp, 8
  0045f	8b c8		 mov	 ecx, eax
  00461	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00467	3b f4		 cmp	 esi, esp
  00469	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 78   : 		return 0;

  0046e	33 c0		 xor	 eax, eax
  00470	e9 98 0a 00 00	 jmp	 $LN56@main
$LN16@main:

; 79   : 	}
; 80   : 	if (month == 10 && day > 31) {

  00475	83 7d c4 0a	 cmp	 DWORD PTR _month$[ebp], 10 ; 0000000aH
  00479	75 36		 jne	 SHORT $LN17@main
  0047b	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  0047f	7e 30		 jle	 SHORT $LN17@main

; 81   : 		cout << "Вы ввели слишком большое значение (в октябре 31 день)" << endl;

  00481	8b f4		 mov	 esi, esp
  00483	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00488	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JAFDHHDC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  0048d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00492	50		 push	 eax
  00493	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00498	83 c4 08	 add	 esp, 8
  0049b	8b c8		 mov	 ecx, eax
  0049d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  004a3	3b f4		 cmp	 esi, esp
  004a5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 82   : 		return 0;

  004aa	33 c0		 xor	 eax, eax
  004ac	e9 5c 0a 00 00	 jmp	 $LN56@main
$LN17@main:

; 83   : 	}
; 84   : 	if (month == 11 && day > 30) {

  004b1	83 7d c4 0b	 cmp	 DWORD PTR _month$[ebp], 11 ; 0000000bH
  004b5	75 36		 jne	 SHORT $LN18@main
  004b7	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  004bb	7e 30		 jle	 SHORT $LN18@main

; 85   : 		cout << "Вы ввели слишком большое значение (в ноябре 30 дней)" << endl;

  004bd	8b f4		 mov	 esi, esp
  004bf	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  004c4	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@IELJHFEE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  004c9	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004ce	50		 push	 eax
  004cf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  004d4	83 c4 08	 add	 esp, 8
  004d7	8b c8		 mov	 ecx, eax
  004d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  004df	3b f4		 cmp	 esi, esp
  004e1	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 86   : 		return 0;

  004e6	33 c0		 xor	 eax, eax
  004e8	e9 20 0a 00 00	 jmp	 $LN56@main
$LN18@main:

; 87   : 	}
; 88   : 	if (month == 12 && day > 31) {

  004ed	83 7d c4 0c	 cmp	 DWORD PTR _month$[ebp], 12 ; 0000000cH
  004f1	75 36		 jne	 SHORT $LN19@main
  004f3	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  004f7	7e 30		 jle	 SHORT $LN19@main

; 89   : 		cout << "Вы ввели слишком большое значение (в декабре 31 день)" << endl;

  004f9	8b f4		 mov	 esi, esp
  004fb	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00500	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JHFIBEAD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00505	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0050a	50		 push	 eax
  0050b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00510	83 c4 08	 add	 esp, 8
  00513	8b c8		 mov	 ecx, eax
  00515	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0051b	3b f4		 cmp	 esi, esp
  0051d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 90   : 		return 0;

  00522	33 c0		 xor	 eax, eax
  00524	e9 e4 09 00 00	 jmp	 $LN56@main
$LN19@main:

; 91   : 	}
; 92   : 
; 93   : 	//Тут определяем правильно ли введен месяц
; 94   : 
; 95   : 	if (month > 12) {

  00529	83 7d c4 0c	 cmp	 DWORD PTR _month$[ebp], 12 ; 0000000cH
  0052d	7e 24		 jle	 SHORT $LN20@main

; 96   : 		cout << "Неверный формат месяца, а именно:месяц больше 12";

  0052f	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CEJLHCGC@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@
  00534	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00539	50		 push	 eax
  0053a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0053f	83 c4 08	 add	 esp, 8

; 97   : 		exit(0);

  00542	8b f4		 mov	 esi, esp
  00544	6a 00		 push	 0
  00546	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  0054c	3b f4		 cmp	 esi, esp
  0054e	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN20@main:

; 98   : 	}
; 99   : 	if (month < 1) {

  00553	83 7d c4 01	 cmp	 DWORD PTR _month$[ebp], 1
  00557	7d 24		 jge	 SHORT $LN21@main

; 100  : 		cout << "Неверный формат месяца, а именно:месяц меньше 1";

  00559	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CIPDFLEI@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@
  0055e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00563	50		 push	 eax
  00564	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00569	83 c4 08	 add	 esp, 8

; 101  : 		exit(0);

  0056c	8b f4		 mov	 esi, esp
  0056e	6a 00		 push	 0
  00570	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00576	3b f4		 cmp	 esi, esp
  00578	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN21@main:

; 102  : 	}
; 103  : 
; 104  : 
; 105  : 	//тут определяем правильно ли ввели год или нет
; 106  : 	if (year < 0) {

  0057d	83 7d b8 00	 cmp	 DWORD PTR _year$[ebp], 0
  00581	7d 30		 jge	 SHORT $LN22@main

; 107  : 		cout << "Вы неправильно ввели год, а именно: год отрицательный" << endl;

  00583	8b f4		 mov	 esi, esp
  00585	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0058a	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MNFJJKPE@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?c?n?d?0?5?$OA?5?h?l?e@
  0058f	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00594	50		 push	 eax
  00595	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0059a	83 c4 08	 add	 esp, 8
  0059d	8b c8		 mov	 ecx, eax
  0059f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  005a5	3b f4		 cmp	 esi, esp
  005a7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 108  : 		return 0;

  005ac	33 c0		 xor	 eax, eax
  005ae	e9 5a 09 00 00	 jmp	 $LN56@main
$LN22@main:

; 109  : 	}
; 110  : 
; 111  : 	//тут определяем год високосный или нет
; 112  : 
; 113  : 	leapOrNot(year);

  005b3	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  005b6	50		 push	 eax
  005b7	e8 00 00 00 00	 call	 ?leapOrNot@@YA_NH@Z	; leapOrNot
  005bc	83 c4 04	 add	 esp, 4

; 114  : 
; 115  : 
; 116  : 	//Тут мы считаем порядковый номер дня в году
; 117  : 
; 118  : 
; 119  : 	NumberOfDay(month, days, day, year);

  005bf	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  005c2	50		 push	 eax
  005c3	8b 4d d0	 mov	 ecx, DWORD PTR _day$[ebp]
  005c6	51		 push	 ecx
  005c7	8b 55 a0	 mov	 edx, DWORD PTR _days$[ebp]
  005ca	52		 push	 edx
  005cb	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  005ce	50		 push	 eax
  005cf	e8 00 00 00 00	 call	 ?NumberOfDay@@YAHHHHH@Z	; NumberOfDay
  005d4	83 c4 10	 add	 esp, 16			; 00000010H

; 120  : 	/*A= NumberOfDay(month, days, day, year);*/
; 121  : 	cout << "Порядковый номер дня: " << NumberOfDay(month, days, day, year)<< endl;

  005d7	8b f4		 mov	 esi, esp
  005d9	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  005de	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  005e1	50		 push	 eax
  005e2	8b 4d d0	 mov	 ecx, DWORD PTR _day$[ebp]
  005e5	51		 push	 ecx
  005e6	8b 55 a0	 mov	 edx, DWORD PTR _days$[ebp]
  005e9	52		 push	 edx
  005ea	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  005ed	50		 push	 eax
  005ee	e8 00 00 00 00	 call	 ?NumberOfDay@@YAHHHHH@Z	; NumberOfDay
  005f3	83 c4 10	 add	 esp, 16			; 00000010H
  005f6	8b fc		 mov	 edi, esp
  005f8	50		 push	 eax
  005f9	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@KNEJGAJJ@?O?n?p?$PP?d?j?n?b?$PL?i?5?m?n?l?e?p?5?d?m?$PP?3?5@
  005fe	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00604	51		 push	 ecx
  00605	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0060a	83 c4 08	 add	 esp, 8
  0060d	8b c8		 mov	 ecx, eax
  0060f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00615	3b fc		 cmp	 edi, esp
  00617	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0061c	8b c8		 mov	 ecx, eax
  0061e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00624	3b f4		 cmp	 esi, esp
  00626	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 122  : 	days = 0;

  0062b	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _days$[ebp], 0

; 123  : 	day = 0;

  00632	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _day$[ebp], 0

; 124  : 
; 125  : 
; 126  : 
; 127  : 
; 128  : 	//Тут мы вводим день рождения 
; 129  : 	cout << "Введите вашу ближайшую дату дня рождения 'ДДММГГГГ': ";

  00639	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@MMHMHLB@?B?b?e?d?h?r?e?5?b?$OA?x?s?5?a?k?h?f?$OA?i?x?s?$PO?5?d?$OA?r?s?5?d?m?$PP@
  0063e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00643	50		 push	 eax
  00644	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00649	83 c4 08	 add	 esp, 8

; 130  : 	cin >> data;

  0064c	8b f4		 mov	 esi, esp
  0064e	8d 45 dc	 lea	 eax, DWORD PTR _data$[ebp]
  00651	50		 push	 eax
  00652	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00658	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??5?$basic_istream@DU?$char_traits@D@std@@@std@@QAEAAV01@AAH@Z
  0065e	3b f4		 cmp	 esi, esp
  00660	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 131  : 
; 132  : 	day = data / 1000000; //потому что переменная содержит восемь цифр и шесть цифр у нас отсекается у даты. получаем просто день. 

  00665	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  00668	99		 cdq
  00669	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0066e	f7 f9		 idiv	 ecx
  00670	89 45 d0	 mov	 DWORD PTR _day$[ebp], eax

; 133  : 	month = (data % 1000000) / 10000;

  00673	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  00676	99		 cdq
  00677	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0067c	f7 f9		 idiv	 ecx
  0067e	8b c2		 mov	 eax, edx
  00680	99		 cdq
  00681	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00686	f7 f9		 idiv	 ecx
  00688	89 45 c4	 mov	 DWORD PTR _month$[ebp], eax

; 134  : 	year = data % 10000;

  0068b	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  0068e	99		 cdq
  0068f	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00694	f7 f9		 idiv	 ecx
  00696	89 55 b8	 mov	 DWORD PTR _year$[ebp], edx

; 135  : 
; 136  : 	
; 137  : 
; 138  : 	//Если год високосный в феврале 29 дней
; 139  : 	if (year % 4 == 0) {

  00699	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  0069c	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  006a1	79 05		 jns	 SHORT $LN65@main
  006a3	48		 dec	 eax
  006a4	83 c8 fc	 or	 eax, -4			; fffffffcH
  006a7	40		 inc	 eax
$LN65@main:
  006a8	85 c0		 test	 eax, eax
  006aa	75 13		 jne	 SHORT $LN23@main

; 140  : 		Months[1] = 29;

  006ac	b8 04 00 00 00	 mov	 eax, 4
  006b1	c1 e0 00	 shl	 eax, 0
  006b4	c7 84 05 2c ff
	ff ff 1d 00 00
	00		 mov	 DWORD PTR _Months$[ebp+eax], 29 ; 0000001dH
$LN23@main:

; 141  : 	}
; 142  : 
; 143  : 
; 144  : 	//проверка правильности написания дней
; 145  : 	if (month == 01 && day > 31) {

  006bf	83 7d c4 01	 cmp	 DWORD PTR _month$[ebp], 1
  006c3	75 36		 jne	 SHORT $LN24@main
  006c5	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  006c9	7e 30		 jle	 SHORT $LN24@main

; 146  : 		cout << "Вы ввели слишком большое значение (в январе 31 день)" << endl;

  006cb	8b f4		 mov	 esi, esp
  006cd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  006d2	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NLBOJDFJ@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  006d7	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006dc	50		 push	 eax
  006dd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  006e2	83 c4 08	 add	 esp, 8
  006e5	8b c8		 mov	 ecx, eax
  006e7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  006ed	3b f4		 cmp	 esi, esp
  006ef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 147  : 		return 0;

  006f4	33 c0		 xor	 eax, eax
  006f6	e9 12 08 00 00	 jmp	 $LN56@main
$LN24@main:

; 148  : 	}
; 149  : 	if (month == 02 && year % 4 != 0 && day > 28) {

  006fb	83 7d c4 02	 cmp	 DWORD PTR _month$[ebp], 2
  006ff	75 49		 jne	 SHORT $LN25@main
  00701	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00704	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00709	79 05		 jns	 SHORT $LN66@main
  0070b	48		 dec	 eax
  0070c	83 c8 fc	 or	 eax, -4			; fffffffcH
  0070f	40		 inc	 eax
$LN66@main:
  00710	85 c0		 test	 eax, eax
  00712	74 36		 je	 SHORT $LN25@main
  00714	83 7d d0 1c	 cmp	 DWORD PTR _day$[ebp], 28 ; 0000001cH
  00718	7e 30		 jle	 SHORT $LN25@main

; 150  : 		cout << "Вы ввели слишком большое значение (в феврале в невисокосном году 28 дней)" << endl;

  0071a	8b f4		 mov	 esi, esp
  0071c	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00721	68 00 00 00 00	 push	 OFFSET ??_C@_0EK@IMLLBPBI@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00726	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0072b	50		 push	 eax
  0072c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00731	83 c4 08	 add	 esp, 8
  00734	8b c8		 mov	 ecx, eax
  00736	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0073c	3b f4		 cmp	 esi, esp
  0073e	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 151  : 		return 0;

  00743	33 c0		 xor	 eax, eax
  00745	e9 c3 07 00 00	 jmp	 $LN56@main
$LN25@main:

; 152  : 	}
; 153  : 	if (month == 02 && year % 4 == 0 && day > 29) {

  0074a	83 7d c4 02	 cmp	 DWORD PTR _month$[ebp], 2
  0074e	75 49		 jne	 SHORT $LN26@main
  00750	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00753	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00758	79 05		 jns	 SHORT $LN67@main
  0075a	48		 dec	 eax
  0075b	83 c8 fc	 or	 eax, -4			; fffffffcH
  0075e	40		 inc	 eax
$LN67@main:
  0075f	85 c0		 test	 eax, eax
  00761	75 36		 jne	 SHORT $LN26@main
  00763	83 7d d0 1d	 cmp	 DWORD PTR _day$[ebp], 29 ; 0000001dH
  00767	7e 30		 jle	 SHORT $LN26@main

; 154  : 		cout << "Вы ввели слишком большое значение (в феврале в високосном году 29 дней)" << endl;

  00769	8b f4		 mov	 esi, esp
  0076b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00770	68 00 00 00 00	 push	 OFFSET ??_C@_0EI@KLKDCIPD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00775	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0077a	50		 push	 eax
  0077b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00780	83 c4 08	 add	 esp, 8
  00783	8b c8		 mov	 ecx, eax
  00785	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0078b	3b f4		 cmp	 esi, esp
  0078d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 155  : 		return 0;

  00792	33 c0		 xor	 eax, eax
  00794	e9 74 07 00 00	 jmp	 $LN56@main
$LN26@main:

; 156  : 	}
; 157  : 	if (month == 03 && day > 31) {

  00799	83 7d c4 03	 cmp	 DWORD PTR _month$[ebp], 3
  0079d	75 36		 jne	 SHORT $LN27@main
  0079f	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  007a3	7e 30		 jle	 SHORT $LN27@main

; 158  : 		cout << "Вы ввели слишком большое значение (в марте 31 день)" << endl;

  007a5	8b f4		 mov	 esi, esp
  007a7	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007ac	68 00 00 00 00	 push	 OFFSET ??_C@_0DE@PFIFBEOG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  007b1	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007b6	50		 push	 eax
  007b7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007bc	83 c4 08	 add	 esp, 8
  007bf	8b c8		 mov	 ecx, eax
  007c1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  007c7	3b f4		 cmp	 esi, esp
  007c9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 159  : 		return 0;

  007ce	33 c0		 xor	 eax, eax
  007d0	e9 38 07 00 00	 jmp	 $LN56@main
$LN27@main:

; 160  : 	}
; 161  : 	if (month == 04 && day > 30) {

  007d5	83 7d c4 04	 cmp	 DWORD PTR _month$[ebp], 4
  007d9	75 36		 jne	 SHORT $LN28@main
  007db	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  007df	7e 30		 jle	 SHORT $LN28@main

; 162  : 		cout << "Вы ввели слишком большое значение (в апреле 30 дней)" << endl;

  007e1	8b f4		 mov	 esi, esp
  007e3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  007e8	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@NPKPHLGH@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  007ed	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007f2	50		 push	 eax
  007f3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  007f8	83 c4 08	 add	 esp, 8
  007fb	8b c8		 mov	 ecx, eax
  007fd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00803	3b f4		 cmp	 esi, esp
  00805	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 163  : 		return 0;

  0080a	33 c0		 xor	 eax, eax
  0080c	e9 fc 06 00 00	 jmp	 $LN56@main
$LN28@main:

; 164  : 	}
; 165  : 	if (month == 05 && day > 31) {

  00811	83 7d c4 05	 cmp	 DWORD PTR _month$[ebp], 5
  00815	75 36		 jne	 SHORT $LN29@main
  00817	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  0081b	7e 30		 jle	 SHORT $LN29@main

; 166  : 		cout << "Вы ввели слишком большое значение (в мае 31 день)" << endl;

  0081d	8b f4		 mov	 esi, esp
  0081f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00824	68 00 00 00 00	 push	 OFFSET ??_C@_0DC@KGGDJCKF@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00829	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0082e	50		 push	 eax
  0082f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00834	83 c4 08	 add	 esp, 8
  00837	8b c8		 mov	 ecx, eax
  00839	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0083f	3b f4		 cmp	 esi, esp
  00841	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 167  : 		return 0;

  00846	33 c0		 xor	 eax, eax
  00848	e9 c0 06 00 00	 jmp	 $LN56@main
$LN29@main:

; 168  : 	}
; 169  : 	if (month == 06 && day > 30) {

  0084d	83 7d c4 06	 cmp	 DWORD PTR _month$[ebp], 6
  00851	75 36		 jne	 SHORT $LN30@main
  00853	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  00857	7e 30		 jle	 SHORT $LN30@main

; 170  : 		cout << "Вы ввели слишком большое значение (в июне 30 дней)" << endl;

  00859	8b f4		 mov	 esi, esp
  0085b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00860	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@LCIHLNIN@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00865	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0086a	50		 push	 eax
  0086b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00870	83 c4 08	 add	 esp, 8
  00873	8b c8		 mov	 ecx, eax
  00875	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0087b	3b f4		 cmp	 esi, esp
  0087d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 171  : 		return 0;

  00882	33 c0		 xor	 eax, eax
  00884	e9 84 06 00 00	 jmp	 $LN56@main
$LN30@main:

; 172  : 	}
; 173  : 	if (month == 07 && day > 31) {

  00889	83 7d c4 07	 cmp	 DWORD PTR _month$[ebp], 7
  0088d	75 36		 jne	 SHORT $LN31@main
  0088f	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  00893	7e 30		 jle	 SHORT $LN31@main

; 174  : 		cout << "Вы ввели слишком большое значение (в июле 31 день)" << endl;

  00895	8b f4		 mov	 esi, esp
  00897	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0089c	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@HODJBKEG@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  008a1	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008a6	50		 push	 eax
  008a7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008ac	83 c4 08	 add	 esp, 8
  008af	8b c8		 mov	 ecx, eax
  008b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  008b7	3b f4		 cmp	 esi, esp
  008b9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 175  : 		return 0;

  008be	33 c0		 xor	 eax, eax
  008c0	e9 48 06 00 00	 jmp	 $LN56@main
$LN31@main:

; 176  : 	}
; 177  : 	if (month == 8 && day > 31) {

  008c5	83 7d c4 08	 cmp	 DWORD PTR _month$[ebp], 8
  008c9	75 36		 jne	 SHORT $LN32@main
  008cb	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  008cf	7e 30		 jle	 SHORT $LN32@main

; 178  : 		cout << "Вы ввели слишком большое значение (в августе 31 день)" << endl;

  008d1	8b f4		 mov	 esi, esp
  008d3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  008d8	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@CNDEPNCE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  008dd	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008e2	50		 push	 eax
  008e3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  008e8	83 c4 08	 add	 esp, 8
  008eb	8b c8		 mov	 ecx, eax
  008ed	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  008f3	3b f4		 cmp	 esi, esp
  008f5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 179  : 		return 0;

  008fa	33 c0		 xor	 eax, eax
  008fc	e9 0c 06 00 00	 jmp	 $LN56@main
$LN32@main:

; 180  : 	}
; 181  : 	if (month == 9 && day > 30) {

  00901	83 7d c4 09	 cmp	 DWORD PTR _month$[ebp], 9
  00905	75 36		 jne	 SHORT $LN33@main
  00907	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  0090b	7e 30		 jle	 SHORT $LN33@main

; 182  : 		cout << "Вы ввели слишком большое значение (в сентябре 30 дней)" << endl;

  0090d	8b f4		 mov	 esi, esp
  0090f	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00914	68 00 00 00 00	 push	 OFFSET ??_C@_0DH@FHAFLEFC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00919	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0091e	50		 push	 eax
  0091f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00924	83 c4 08	 add	 esp, 8
  00927	8b c8		 mov	 ecx, eax
  00929	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0092f	3b f4		 cmp	 esi, esp
  00931	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 183  : 		return 0;

  00936	33 c0		 xor	 eax, eax
  00938	e9 d0 05 00 00	 jmp	 $LN56@main
$LN33@main:

; 184  : 	}
; 185  : 	if (month == 10 && day > 31) {

  0093d	83 7d c4 0a	 cmp	 DWORD PTR _month$[ebp], 10 ; 0000000aH
  00941	75 36		 jne	 SHORT $LN34@main
  00943	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  00947	7e 30		 jle	 SHORT $LN34@main

; 186  : 		cout << "Вы ввели слишком большое значение (в октябре 31 день)" << endl;

  00949	8b f4		 mov	 esi, esp
  0094b	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00950	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JAFDHHDC@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00955	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0095a	50		 push	 eax
  0095b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00960	83 c4 08	 add	 esp, 8
  00963	8b c8		 mov	 ecx, eax
  00965	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  0096b	3b f4		 cmp	 esi, esp
  0096d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 187  : 		return 0;

  00972	33 c0		 xor	 eax, eax
  00974	e9 94 05 00 00	 jmp	 $LN56@main
$LN34@main:

; 188  : 	}
; 189  : 	if (month == 11 && day > 30) {

  00979	83 7d c4 0b	 cmp	 DWORD PTR _month$[ebp], 11 ; 0000000bH
  0097d	75 36		 jne	 SHORT $LN35@main
  0097f	83 7d d0 1e	 cmp	 DWORD PTR _day$[ebp], 30 ; 0000001eH
  00983	7e 30		 jle	 SHORT $LN35@main

; 190  : 		cout << "Вы ввели слишком большое значение (в ноябре 30 дней)" << endl;

  00985	8b f4		 mov	 esi, esp
  00987	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  0098c	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@IELJHFEE@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  00991	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00996	50		 push	 eax
  00997	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  0099c	83 c4 08	 add	 esp, 8
  0099f	8b c8		 mov	 ecx, eax
  009a1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  009a7	3b f4		 cmp	 esi, esp
  009a9	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 191  : 		return 0;

  009ae	33 c0		 xor	 eax, eax
  009b0	e9 58 05 00 00	 jmp	 $LN56@main
$LN35@main:

; 192  : 	}
; 193  : 	if (month == 12 && day > 31) {

  009b5	83 7d c4 0c	 cmp	 DWORD PTR _month$[ebp], 12 ; 0000000cH
  009b9	75 36		 jne	 SHORT $LN4@main
  009bb	83 7d d0 1f	 cmp	 DWORD PTR _day$[ebp], 31 ; 0000001fH
  009bf	7e 30		 jle	 SHORT $LN4@main

; 194  : 		cout << "Вы ввели слишком большое значение (в декабре 31 день)" << endl;

  009c1	8b f4		 mov	 esi, esp
  009c3	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  009c8	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@JHFIBEAD@?B?$PL?5?b?b?e?k?h?5?q?k?h?x?j?n?l?5?a?n?k?$PM?x?n?e?5?g?m?$OA?w?e?m@
  009cd	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  009d2	50		 push	 eax
  009d3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  009d8	83 c4 08	 add	 esp, 8
  009db	8b c8		 mov	 ecx, eax
  009dd	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  009e3	3b f4		 cmp	 esi, esp
  009e5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 195  : 		return 0;

  009ea	33 c0		 xor	 eax, eax
  009ec	e9 1c 05 00 00	 jmp	 $LN56@main
$LN4@main:

; 196  : 	}
; 197  : 	
; 198  : 	//проверка кол-ва цифр (их должно быть 8)
; 199  : 	while (data > 0) {

  009f1	83 7d dc 00	 cmp	 DWORD PTR _data$[ebp], 0
  009f5	7e 1f		 jle	 SHORT $LN5@main

; 200  : 		data /= 10; // /= значит разделить переменную на значение и ответ присвоить этой же переменной

  009f7	8b 45 dc	 mov	 eax, DWORD PTR _data$[ebp]
  009fa	99		 cdq
  009fb	b9 0a 00 00 00	 mov	 ecx, 10			; 0000000aH
  00a00	f7 f9		 idiv	 ecx
  00a02	89 45 dc	 mov	 DWORD PTR _data$[ebp], eax

; 201  : 		count++;

  00a05	8b 85 64 ff ff
	ff		 mov	 eax, DWORD PTR _count$[ebp]
  00a0b	83 c0 01	 add	 eax, 1
  00a0e	89 85 64 ff ff
	ff		 mov	 DWORD PTR _count$[ebp], eax

; 202  : 	}

  00a14	eb db		 jmp	 SHORT $LN4@main
$LN5@main:

; 203  : 	if (count < 7 && count > 8) {

  00a16	83 bd 64 ff ff
	ff 07		 cmp	 DWORD PTR _count$[ebp], 7
  00a1d	7d 2d		 jge	 SHORT $LN37@main
  00a1f	83 bd 64 ff ff
	ff 08		 cmp	 DWORD PTR _count$[ebp], 8
  00a26	7e 24		 jle	 SHORT $LN37@main

; 204  : 		cout << "Неверное количество данных или в дату введенна цифра";

  00a28	68 00 00 00 00	 push	 OFFSET ??_C@_0DF@GBNBKAPK@?M?e?b?e?p?m?n?e?5?j?n?k?h?w?e?q?r?b?n?5?d?$OA?m?m?$PL?u?5?h?k?h?5@
  00a2d	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00a32	50		 push	 eax
  00a33	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a38	83 c4 08	 add	 esp, 8

; 205  : 		exit(0);

  00a3b	8b f4		 mov	 esi, esp
  00a3d	6a 00		 push	 0
  00a3f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00a45	3b f4		 cmp	 esi, esp
  00a47	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN37@main:

; 206  : 	}
; 207  : 	//Тут определяем правильно ли введен месяц
; 208  : 
; 209  : 	if (month > 12) {

  00a4c	83 7d c4 0c	 cmp	 DWORD PTR _month$[ebp], 12 ; 0000000cH
  00a50	7e 24		 jle	 SHORT $LN38@main

; 210  : 		cout << "Неверный формат месяца, а именно:месяц больше 12";

  00a52	68 00 00 00 00	 push	 OFFSET ??_C@_0DB@CEJLHCGC@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@
  00a57	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00a5c	50		 push	 eax
  00a5d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a62	83 c4 08	 add	 esp, 8

; 211  : 		exit(0);

  00a65	8b f4		 mov	 esi, esp
  00a67	6a 00		 push	 0
  00a69	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00a6f	3b f4		 cmp	 esi, esp
  00a71	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN38@main:

; 212  : 	}
; 213  : 	if (month < 1) {

  00a76	83 7d c4 01	 cmp	 DWORD PTR _month$[ebp], 1
  00a7a	7d 24		 jge	 SHORT $LN39@main

; 214  : 		cout << "Неверный формат месяца, а именно:месяц меньше 1";

  00a7c	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@CIPDFLEI@?M?e?b?e?p?m?$PL?i?5?t?n?p?l?$OA?r?5?l?e?q?$PP?v?$OA?0?5?$OA?5?h?l?e?m?m@
  00a81	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00a86	50		 push	 eax
  00a87	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00a8c	83 c4 08	 add	 esp, 8

; 215  : 		exit(0);

  00a8f	8b f4		 mov	 esi, esp
  00a91	6a 00		 push	 0
  00a93	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__exit
  00a99	3b f4		 cmp	 esi, esp
  00a9b	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN39@main:

; 216  : 	}
; 217  : 
; 218  : 
; 219  : 	////далее у нас подсчитывается текущая дата для того,чтобы потом вычислить сколько дней осталось до ближайшего дня рождения
; 220  : 	
; 221  : 	
; 222  : 	
; 223  : 
; 224  : 	
; 225  : 	NumberOfDay(month, days, day, year);

  00aa0	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00aa3	50		 push	 eax
  00aa4	8b 4d d0	 mov	 ecx, DWORD PTR _day$[ebp]
  00aa7	51		 push	 ecx
  00aa8	8b 55 a0	 mov	 edx, DWORD PTR _days$[ebp]
  00aab	52		 push	 edx
  00aac	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  00aaf	50		 push	 eax
  00ab0	e8 00 00 00 00	 call	 ?NumberOfDay@@YAHHHHH@Z	; NumberOfDay
  00ab5	83 c4 10	 add	 esp, 16			; 00000010H

; 226  : 	Birthday = NumberOfDay(month, days, day, year);

  00ab8	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00abb	50		 push	 eax
  00abc	8b 4d d0	 mov	 ecx, DWORD PTR _day$[ebp]
  00abf	51		 push	 ecx
  00ac0	8b 55 a0	 mov	 edx, DWORD PTR _days$[ebp]
  00ac3	52		 push	 edx
  00ac4	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  00ac7	50		 push	 eax
  00ac8	e8 00 00 00 00	 call	 ?NumberOfDay@@YAHHHHH@Z	; NumberOfDay
  00acd	83 c4 10	 add	 esp, 16			; 00000010H
  00ad0	89 45 94	 mov	 DWORD PTR _Birthday$[ebp], eax

; 227  : 	days = 0;

  00ad3	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _days$[ebp], 0

; 228  : 	day = 0;

  00ada	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _day$[ebp], 0

; 229  : 	YearOfBirthday = year;

  00ae1	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00ae4	89 45 88	 mov	 DWORD PTR _YearOfBirthday$[ebp], eax

; 230  : 	int MOUNTH = month;

  00ae7	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  00aea	89 85 20 ff ff
	ff		 mov	 DWORD PTR _MOUNTH$[ebp], eax

; 231  : 	year = 0;

  00af0	c7 45 b8 00 00
	00 00		 mov	 DWORD PTR _year$[ebp], 0

; 232  : 	month = 0;

  00af7	c7 45 c4 00 00
	00 00		 mov	 DWORD PTR _month$[ebp], 0

; 233  : 
; 234  : 	day = DATA / 1000000; //потому что переменная содержит восемь цифр и шесть цифр у нас отсекается у даты. получаем просто день. 

  00afe	8b 45 e8	 mov	 eax, DWORD PTR _DATA$[ebp]
  00b01	99		 cdq
  00b02	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00b07	f7 f9		 idiv	 ecx
  00b09	89 45 d0	 mov	 DWORD PTR _day$[ebp], eax

; 235  : 	month = (DATA % 1000000) / 10000;

  00b0c	8b 45 e8	 mov	 eax, DWORD PTR _DATA$[ebp]
  00b0f	99		 cdq
  00b10	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00b15	f7 f9		 idiv	 ecx
  00b17	8b c2		 mov	 eax, edx
  00b19	99		 cdq
  00b1a	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00b1f	f7 f9		 idiv	 ecx
  00b21	89 45 c4	 mov	 DWORD PTR _month$[ebp], eax

; 236  : 	year = DATA % 10000;

  00b24	8b 45 e8	 mov	 eax, DWORD PTR _DATA$[ebp]
  00b27	99		 cdq
  00b28	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  00b2d	f7 f9		 idiv	 ecx
  00b2f	89 55 b8	 mov	 DWORD PTR _year$[ebp], edx

; 237  : 
; 238  : 
; 239  : 	//Если год високосный в феврале 29 дней
; 240  : 	if (year % 4 == 0) {

  00b32	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00b35	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00b3a	79 05		 jns	 SHORT $LN68@main
  00b3c	48		 dec	 eax
  00b3d	83 c8 fc	 or	 eax, -4			; fffffffcH
  00b40	40		 inc	 eax
$LN68@main:
  00b41	85 c0		 test	 eax, eax
  00b43	75 13		 jne	 SHORT $LN40@main

; 241  : 		Months[1] = 29;

  00b45	b8 04 00 00 00	 mov	 eax, 4
  00b4a	c1 e0 00	 shl	 eax, 0
  00b4d	c7 84 05 2c ff
	ff ff 1d 00 00
	00		 mov	 DWORD PTR _Months$[ebp+eax], 29 ; 0000001dH
$LN40@main:

; 242  : 	}
; 243  : 
; 244  : 
; 245  : 
; 246  : 
; 247  : 	NumberOfDay(month, days, day, year);

  00b58	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00b5b	50		 push	 eax
  00b5c	8b 4d d0	 mov	 ecx, DWORD PTR _day$[ebp]
  00b5f	51		 push	 ecx
  00b60	8b 55 a0	 mov	 edx, DWORD PTR _days$[ebp]
  00b63	52		 push	 edx
  00b64	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  00b67	50		 push	 eax
  00b68	e8 00 00 00 00	 call	 ?NumberOfDay@@YAHHHHH@Z	; NumberOfDay
  00b6d	83 c4 10	 add	 esp, 16			; 00000010H

; 248  : 	NumberOfcurrentDay = NumberOfDay(month, days, day, year);

  00b70	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00b73	50		 push	 eax
  00b74	8b 4d d0	 mov	 ecx, DWORD PTR _day$[ebp]
  00b77	51		 push	 ecx
  00b78	8b 55 a0	 mov	 edx, DWORD PTR _days$[ebp]
  00b7b	52		 push	 edx
  00b7c	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  00b7f	50		 push	 eax
  00b80	e8 00 00 00 00	 call	 ?NumberOfDay@@YAHHHHH@Z	; NumberOfDay
  00b85	83 c4 10	 add	 esp, 16			; 00000010H
  00b88	89 85 7c ff ff
	ff		 mov	 DWORD PTR _NumberOfcurrentDay$[ebp], eax

; 249  : 	//cout << "Порядковый номер дня: " << numberofday << endl;
; 250  : 	days = 0;

  00b8e	c7 45 a0 00 00
	00 00		 mov	 DWORD PTR _days$[ebp], 0

; 251  : 	day = 0;

  00b95	c7 45 d0 00 00
	00 00		 mov	 DWORD PTR _day$[ebp], 0

; 252  : 
; 253  : 
; 254  : 
; 255  : 	//Высчитываем сколько дней осталось до дня рождения
; 256  : 	if (year == YearOfBirthday && Birthday>NumberOfcurrentDay) {

  00b9c	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00b9f	3b 45 88	 cmp	 eax, DWORD PTR _YearOfBirthday$[ebp]
  00ba2	75 6f		 jne	 SHORT $LN41@main
  00ba4	8b 45 94	 mov	 eax, DWORD PTR _Birthday$[ebp]
  00ba7	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00bad	7e 64		 jle	 SHORT $LN41@main

; 257  : 		left=Birthday-NumberOfcurrentDay;

  00baf	8b 45 94	 mov	 eax, DWORD PTR _Birthday$[ebp]
  00bb2	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00bb8	89 85 70 ff ff
	ff		 mov	 DWORD PTR _left$[ebp], eax

; 258  : 		cout << "До вашего дня рождения осталось "<<left<<" дней"<< endl;	

  00bbe	8b f4		 mov	 esi, esp
  00bc0	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00bc5	68 00 00 00 00	 push	 OFFSET ??_C@_05JAEFPJHO@?5?d?m?e?i@
  00bca	8b fc		 mov	 edi, esp
  00bcc	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _left$[ebp]
  00bd2	50		 push	 eax
  00bd3	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@
  00bd8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00bde	51		 push	 ecx
  00bdf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00be4	83 c4 08	 add	 esp, 8
  00be7	8b c8		 mov	 ecx, eax
  00be9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00bef	3b fc		 cmp	 edi, esp
  00bf1	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00bf6	50		 push	 eax
  00bf7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00bfc	83 c4 08	 add	 esp, 8
  00bff	8b c8		 mov	 ecx, eax
  00c01	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00c07	3b f4		 cmp	 esi, esp
  00c09	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 259  : 	}

  00c0e	e9 b8 02 00 00	 jmp	 $LN42@main
$LN41@main:

; 260  : 	else if (YearOfBirthday==year+1 && year % 4 == 0) {

  00c13	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00c16	83 c0 01	 add	 eax, 1
  00c19	39 45 88	 cmp	 DWORD PTR _YearOfBirthday$[ebp], eax
  00c1c	75 7c		 jne	 SHORT $LN43@main
  00c1e	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00c21	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00c26	79 05		 jns	 SHORT $LN69@main
  00c28	48		 dec	 eax
  00c29	83 c8 fc	 or	 eax, -4			; fffffffcH
  00c2c	40		 inc	 eax
$LN69@main:
  00c2d	85 c0		 test	 eax, eax
  00c2f	75 69		 jne	 SHORT $LN43@main

; 261  : 		left = 366-NumberOfcurrentDay + Birthday;

  00c31	b8 6e 01 00 00	 mov	 eax, 366		; 0000016eH
  00c36	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00c3c	03 45 94	 add	 eax, DWORD PTR _Birthday$[ebp]
  00c3f	89 85 70 ff ff
	ff		 mov	 DWORD PTR _left$[ebp], eax

; 262  : 		cout << "До вашего дня рождения осталось " << left << " дней" << endl;

  00c45	8b f4		 mov	 esi, esp
  00c47	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00c4c	68 00 00 00 00	 push	 OFFSET ??_C@_05JAEFPJHO@?5?d?m?e?i@
  00c51	8b fc		 mov	 edi, esp
  00c53	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _left$[ebp]
  00c59	50		 push	 eax
  00c5a	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@
  00c5f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00c65	51		 push	 ecx
  00c66	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c6b	83 c4 08	 add	 esp, 8
  00c6e	8b c8		 mov	 ecx, eax
  00c70	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00c76	3b fc		 cmp	 edi, esp
  00c78	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00c7d	50		 push	 eax
  00c7e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00c83	83 c4 08	 add	 esp, 8
  00c86	8b c8		 mov	 ecx, eax
  00c88	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00c8e	3b f4		 cmp	 esi, esp
  00c90	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 263  : 	}

  00c95	e9 31 02 00 00	 jmp	 $LN42@main
$LN43@main:

; 264  : 	else if (YearOfBirthday == year + 1 && year % 4 != 0) {

  00c9a	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00c9d	83 c0 01	 add	 eax, 1
  00ca0	39 45 88	 cmp	 DWORD PTR _YearOfBirthday$[ebp], eax
  00ca3	75 55		 jne	 SHORT $LN45@main
  00ca5	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00ca8	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00cad	79 05		 jns	 SHORT $LN70@main
  00caf	48		 dec	 eax
  00cb0	83 c8 fc	 or	 eax, -4			; fffffffcH
  00cb3	40		 inc	 eax
$LN70@main:
  00cb4	85 c0		 test	 eax, eax
  00cb6	74 42		 je	 SHORT $LN45@main

; 265  : 		left = 365 - NumberOfcurrentDay + Birthday;

  00cb8	b8 6d 01 00 00	 mov	 eax, 365		; 0000016dH
  00cbd	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00cc3	03 45 94	 add	 eax, DWORD PTR _Birthday$[ebp]
  00cc6	89 85 70 ff ff
	ff		 mov	 DWORD PTR _left$[ebp], eax

; 266  : 		cout << "Вы ввели неправильно ближайшую дату рождения, а именно: Ваш ближайший день рождения будет в этом году."<< endl;

  00ccc	8b f4		 mov	 esi, esp
  00cce	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00cd3	68 00 00 00 00	 push	 OFFSET ??_C@_0GH@ENIKJHNH@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@
  00cd8	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00cdd	50		 push	 eax
  00cde	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ce3	83 c4 08	 add	 esp, 8
  00ce6	8b c8		 mov	 ecx, eax
  00ce8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00cee	3b f4		 cmp	 esi, esp
  00cf0	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 267  : 	}

  00cf5	e9 d1 01 00 00	 jmp	 $LN42@main
$LN45@main:

; 268  : 	else if (YearOfBirthday<year) {

  00cfa	8b 45 88	 mov	 eax, DWORD PTR _YearOfBirthday$[ebp]
  00cfd	3b 45 b8	 cmp	 eax, DWORD PTR _year$[ebp]
  00d00	7d 2e		 jge	 SHORT $LN47@main

; 269  : 		cout << "Вы ввели неправильно ближайшую дату рождения, а именно: год ближайшего дня рождения меньше чем текущий год." << endl;

  00d02	8b f4		 mov	 esi, esp
  00d04	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00d09	68 00 00 00 00	 push	 OFFSET ??_C@_0GM@PFCOCJKF@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@
  00d0e	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00d13	50		 push	 eax
  00d14	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00d19	83 c4 08	 add	 esp, 8
  00d1c	8b c8		 mov	 ecx, eax
  00d1e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00d24	3b f4		 cmp	 esi, esp
  00d26	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 270  : 	}

  00d2b	e9 9b 01 00 00	 jmp	 $LN42@main
$LN47@main:

; 271  : 	else if (YearOfBirthday > year + 1) {

  00d30	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00d33	83 c0 01	 add	 eax, 1
  00d36	39 45 88	 cmp	 DWORD PTR _YearOfBirthday$[ebp], eax
  00d39	7e 2e		 jle	 SHORT $LN49@main

; 272  : 		cout << "Вы ввели неправильно ближайшую дату рождения, а именно: ближайший день рождения через несколько лет?! ОГО! Нет, пожалуйста, введите дату правильно." << endl;

  00d3b	8b f4		 mov	 esi, esp
  00d3d	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00d42	68 00 00 00 00	 push	 OFFSET ??_C@_0JE@ENKEGGAB@?B?$PL?5?b?b?e?k?h?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?a?k?h?f?$OA?i?x?s?$PO?5@
  00d47	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00d4c	50		 push	 eax
  00d4d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00d52	83 c4 08	 add	 esp, 8
  00d55	8b c8		 mov	 ecx, eax
  00d57	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00d5d	3b f4		 cmp	 esi, esp
  00d5f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 273  : 	}

  00d64	e9 62 01 00 00	 jmp	 $LN42@main
$LN49@main:

; 274  : 	else if (year == YearOfBirthday && NumberOfcurrentDay > NumberOfcurrentDay && year % 4 == 0) {

  00d69	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00d6c	3b 45 88	 cmp	 eax, DWORD PTR _YearOfBirthday$[ebp]
  00d6f	0f 85 8a 00 00
	00		 jne	 $LN51@main
  00d75	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00d7b	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00d81	7e 7c		 jle	 SHORT $LN51@main
  00d83	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00d86	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00d8b	79 05		 jns	 SHORT $LN71@main
  00d8d	48		 dec	 eax
  00d8e	83 c8 fc	 or	 eax, -4			; fffffffcH
  00d91	40		 inc	 eax
$LN71@main:
  00d92	85 c0		 test	 eax, eax
  00d94	75 69		 jne	 SHORT $LN51@main

; 275  : 		left =366- NumberOfcurrentDay+ Birthday;

  00d96	b8 6e 01 00 00	 mov	 eax, 366		; 0000016eH
  00d9b	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00da1	03 45 94	 add	 eax, DWORD PTR _Birthday$[ebp]
  00da4	89 85 70 ff ff
	ff		 mov	 DWORD PTR _left$[ebp], eax

; 276  : 		cout << "До вашего дня рождения осталось " << left << " дней"<< endl;

  00daa	8b f4		 mov	 esi, esp
  00dac	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00db1	68 00 00 00 00	 push	 OFFSET ??_C@_05JAEFPJHO@?5?d?m?e?i@
  00db6	8b fc		 mov	 edi, esp
  00db8	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _left$[ebp]
  00dbe	50		 push	 eax
  00dbf	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@
  00dc4	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00dca	51		 push	 ecx
  00dcb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00dd0	83 c4 08	 add	 esp, 8
  00dd3	8b c8		 mov	 ecx, eax
  00dd5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00ddb	3b fc		 cmp	 edi, esp
  00ddd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00de2	50		 push	 eax
  00de3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00de8	83 c4 08	 add	 esp, 8
  00deb	8b c8		 mov	 ecx, eax
  00ded	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00df3	3b f4		 cmp	 esi, esp
  00df5	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 277  : 	}

  00dfa	e9 cc 00 00 00	 jmp	 $LN42@main
$LN51@main:

; 278  : 	else if (year == YearOfBirthday && NumberOfcurrentDay > NumberOfcurrentDay && year % 4 != 0) {

  00dff	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00e02	3b 45 88	 cmp	 eax, DWORD PTR _YearOfBirthday$[ebp]
  00e05	0f 85 87 00 00
	00		 jne	 $LN53@main
  00e0b	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00e11	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00e17	7e 79		 jle	 SHORT $LN53@main
  00e19	8b 45 b8	 mov	 eax, DWORD PTR _year$[ebp]
  00e1c	25 03 00 00 80	 and	 eax, -2147483645	; 80000003H
  00e21	79 05		 jns	 SHORT $LN72@main
  00e23	48		 dec	 eax
  00e24	83 c8 fc	 or	 eax, -4			; fffffffcH
  00e27	40		 inc	 eax
$LN72@main:
  00e28	85 c0		 test	 eax, eax
  00e2a	74 66		 je	 SHORT $LN53@main

; 279  : 		left = 365 - NumberOfcurrentDay + Birthday;

  00e2c	b8 6d 01 00 00	 mov	 eax, 365		; 0000016dH
  00e31	2b 85 7c ff ff
	ff		 sub	 eax, DWORD PTR _NumberOfcurrentDay$[ebp]
  00e37	03 45 94	 add	 eax, DWORD PTR _Birthday$[ebp]
  00e3a	89 85 70 ff ff
	ff		 mov	 DWORD PTR _left$[ebp], eax

; 280  : 		cout << "До вашего дня рождения осталось " << left << " дней"<< endl;

  00e40	8b f4		 mov	 esi, esp
  00e42	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00e47	68 00 00 00 00	 push	 OFFSET ??_C@_05JAEFPJHO@?5?d?m?e?i@
  00e4c	8b fc		 mov	 edi, esp
  00e4e	8b 85 70 ff ff
	ff		 mov	 eax, DWORD PTR _left$[ebp]
  00e54	50		 push	 eax
  00e55	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@BFNKMMAC@?D?n?5?b?$OA?x?e?c?n?5?d?m?$PP?5?p?n?f?d?e?m?h?$PP?5?n?q?r?$OA?k?n?q?$PM@
  00e5a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00e60	51		 push	 ecx
  00e61	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00e66	83 c4 08	 add	 esp, 8
  00e69	8b c8		 mov	 ecx, eax
  00e6b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z
  00e71	3b fc		 cmp	 edi, esp
  00e73	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00e78	50		 push	 eax
  00e79	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00e7e	83 c4 08	 add	 esp, 8
  00e81	8b c8		 mov	 ecx, eax
  00e83	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00e89	3b f4		 cmp	 esi, esp
  00e8b	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 281  : 	}

  00e90	eb 39		 jmp	 SHORT $LN42@main
$LN53@main:

; 282  : 	else if (month >month && YearOfBirthday>year) {

  00e92	8b 45 c4	 mov	 eax, DWORD PTR _month$[ebp]
  00e95	3b 45 c4	 cmp	 eax, DWORD PTR _month$[ebp]
  00e98	7e 31		 jle	 SHORT $LN42@main
  00e9a	8b 45 88	 mov	 eax, DWORD PTR _YearOfBirthday$[ebp]
  00e9d	3b 45 b8	 cmp	 eax, DWORD PTR _year$[ebp]
  00ea0	7e 29		 jle	 SHORT $LN42@main

; 283  : 		cout << "Вы неправильно ввели дату. Будьте внимательней." << endl;	

  00ea2	8b f4		 mov	 esi, esp
  00ea4	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00ea9	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@KMMENEPG@?B?$PL?5?m?e?o?p?$OA?b?h?k?$PM?m?n?5?b?b?e?k?h?5?d?$OA?r?s?4?5?A?s?d?$PM@
  00eae	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00eb3	50		 push	 eax
  00eb4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00eb9	83 c4 08	 add	 esp, 8
  00ebc	8b c8		 mov	 ecx, eax
  00ebe	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00ec4	3b f4		 cmp	 esi, esp
  00ec6	e8 00 00 00 00	 call	 __RTC_CheckEsp
$LN42@main:

; 284  : 	}
; 285  : 	cout << "Программа закончила свое выполнение. Благодарим за использование нашего приложения" << endl;

  00ecb	8b f4		 mov	 esi, esp
  00ecd	68 00 00 00 00	 push	 OFFSET ??$endl@DU?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::endl<char,std::char_traits<char> >
  00ed2	68 00 00 00 00	 push	 OFFSET ??_C@_0FD@JINABHDA@?O?p?n?c?p?$OA?l?l?$OA?5?g?$OA?j?n?m?w?h?k?$OA?5?q?b?n?e?5?b?$PL?o?n?k?m@
  00ed7	a1 00 00 00 00	 mov	 eax, DWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00edc	50		 push	 eax
  00edd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
  00ee2	83 c4 08	 add	 esp, 8
  00ee5	8b c8		 mov	 ecx, eax
  00ee7	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAV01@AAV01@@Z@Z
  00eed	3b f4		 cmp	 esi, esp
  00eef	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 286  : 	system("pause");

  00ef4	8b f4		 mov	 esi, esp
  00ef6	68 00 00 00 00	 push	 OFFSET ??_C@_05PDJBBECF@pause@
  00efb	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__system
  00f01	83 c4 04	 add	 esp, 4
  00f04	3b f4		 cmp	 esi, esp
  00f06	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 287  : 	return 0;

  00f0b	33 c0		 xor	 eax, eax
$LN56@main:

; 288  : }

  00f0d	52		 push	 edx
  00f0e	8b cd		 mov	 ecx, ebp
  00f10	50		 push	 eax
  00f11	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN62@main
  00f17	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00f1c	58		 pop	 eax
  00f1d	5a		 pop	 edx
  00f1e	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00f21	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00f28	59		 pop	 ecx
  00f29	5f		 pop	 edi
  00f2a	5e		 pop	 esi
  00f2b	5b		 pop	 ebx
  00f2c	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00f2f	33 cd		 xor	 ecx, ebp
  00f31	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00f36	81 c4 d0 01 00
	00		 add	 esp, 464		; 000001d0H
  00f3c	3b ec		 cmp	 ebp, esp
  00f3e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00f43	8b e5		 mov	 esp, ebp
  00f45	5d		 pop	 ebp
  00f46	c3		 ret	 0
  00f47	90		 npad	 1
$LN62@main:
  00f48	02 00 00 00	 DD	 2
  00f4c	00 00 00 00	 DD	 $LN61@main
$LN61@main:
  00f50	dc ff ff ff	 DD	 -36			; ffffffdcH
  00f54	04 00 00 00	 DD	 4
  00f58	00 00 00 00	 DD	 $LN58@main
  00f5c	2c ff ff ff	 DD	 -212			; ffffff2cH
  00f60	30 00 00 00	 DD	 48			; 00000030H
  00f64	00 00 00 00	 DD	 $LN59@main
$LN59@main:
  00f68	4d		 DB	 77			; 0000004dH
  00f69	6f		 DB	 111			; 0000006fH
  00f6a	6e		 DB	 110			; 0000006eH
  00f6b	74		 DB	 116			; 00000074H
  00f6c	68		 DB	 104			; 00000068H
  00f6d	73		 DB	 115			; 00000073H
  00f6e	00		 DB	 0
$LN58@main:
  00f6f	64		 DB	 100			; 00000064H
  00f70	61		 DB	 97			; 00000061H
  00f71	74		 DB	 116			; 00000074H
  00f72	61		 DB	 97			; 00000061H
  00f73	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_main$0:
  00000	8d 8d 3c fe ff
	ff		 lea	 ecx, DWORD PTR $T2[ebp]
  00006	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0000b	cc		 int	 3
  0000c	cc		 int	 3
  0000d	cc		 int	 3
  0000e	cc		 int	 3
  0000f	cc		 int	 3
__ehhandler$_main:
  00010	90		 npad	 1
  00011	90		 npad	 1
  00012	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00016	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00019	8b 8a 2c fe ff
	ff		 mov	 ecx, DWORD PTR [edx-468]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_main
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_main	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\string
;	COMDAT ?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z
_TEXT	SEGMENT
__Ans$ = -48						; size = 4
__Eptr$ = -36						; size = 4
__Ptr$ = -24						; size = 4
__Errno_ref$ = -12					; size = 4
__$ArrayPad$ = -4					; size = 4
__Str$ = 8						; size = 4
__Idx$ = 12						; size = 4
__Base$ = 16						; size = 4
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z PROC ; std::stoi, COMDAT

; 89   : _NODISCARD inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  0000f	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00020	33 c5		 xor	 eax, ebp
  00022	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00025	b9 00 00 00 00	 mov	 ecx, OFFSET __7B8ECEE4_string
  0002a	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 90   :     int& _Errno_ref  = errno; // Nonzero cost, pay it once

  0002f	8b f4		 mov	 esi, esp
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00037	3b f4		 cmp	 esi, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	89 45 f4	 mov	 DWORD PTR __Errno_ref$[ebp], eax

; 91   :     const char* _Ptr = _Str.c_str();

  00041	8b 4d 08	 mov	 ecx, DWORD PTR __Str$[ebp]
  00044	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  00049	89 45 e8	 mov	 DWORD PTR __Ptr$[ebp], eax

; 92   :     char* _Eptr;
; 93   :     _Errno_ref      = 0;

  0004c	8b 45 f4	 mov	 eax, DWORD PTR __Errno_ref$[ebp]
  0004f	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 94   :     const long _Ans = _CSTD strtol(_Ptr, &_Eptr, _Base);

  00055	8b f4		 mov	 esi, esp
  00057	8b 45 10	 mov	 eax, DWORD PTR __Base$[ebp]
  0005a	50		 push	 eax
  0005b	8d 4d dc	 lea	 ecx, DWORD PTR __Eptr$[ebp]
  0005e	51		 push	 ecx
  0005f	8b 55 e8	 mov	 edx, DWORD PTR __Ptr$[ebp]
  00062	52		 push	 edx
  00063	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strtol
  00069	83 c4 0c	 add	 esp, 12			; 0000000cH
  0006c	3b f4		 cmp	 esi, esp
  0006e	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00073	89 45 d0	 mov	 DWORD PTR __Ans$[ebp], eax

; 95   : 
; 96   :     if (_Ptr == _Eptr) {

  00076	8b 45 e8	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00079	3b 45 dc	 cmp	 eax, DWORD PTR __Eptr$[ebp]
  0007c	75 0a		 jne	 SHORT $LN2@stoi

; 97   :         _Xinvalid_argument("invalid stoi argument");

  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@HGEDEDEC@invalid?5stoi?5argument@
  00083	e8 00 00 00 00	 call	 ?_Xinvalid_argument@std@@YAXPBD@Z ; std::_Xinvalid_argument
$LN2@stoi:

; 98   :     }
; 99   : 
; 100  :     if (_Errno_ref == ERANGE) {

  00088	8b 45 f4	 mov	 eax, DWORD PTR __Errno_ref$[ebp]
  0008b	83 38 22	 cmp	 DWORD PTR [eax], 34	; 00000022H
  0008e	75 0a		 jne	 SHORT $LN3@stoi

; 101  :         _Xout_of_range("stoi argument out of range");

  00090	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@MFFNMGGC@stoi?5argument?5out?5of?5range@
  00095	e8 00 00 00 00	 call	 ?_Xout_of_range@std@@YAXPBD@Z ; std::_Xout_of_range
$LN3@stoi:

; 102  :     }
; 103  : 
; 104  :     if (_Idx) {

  0009a	83 7d 0c 00	 cmp	 DWORD PTR __Idx$[ebp], 0
  0009e	74 0b		 je	 SHORT $LN4@stoi

; 105  :         *_Idx = static_cast<size_t>(_Eptr - _Ptr);

  000a0	8b 45 dc	 mov	 eax, DWORD PTR __Eptr$[ebp]
  000a3	2b 45 e8	 sub	 eax, DWORD PTR __Ptr$[ebp]
  000a6	8b 4d 0c	 mov	 ecx, DWORD PTR __Idx$[ebp]
  000a9	89 01		 mov	 DWORD PTR [ecx], eax
$LN4@stoi:

; 106  :     }
; 107  : 
; 108  :     return static_cast<int>(_Ans);

  000ab	8b 45 d0	 mov	 eax, DWORD PTR __Ans$[ebp]
$LN5@stoi:

; 109  : }

  000ae	52		 push	 edx
  000af	8b cd		 mov	 ecx, ebp
  000b1	50		 push	 eax
  000b2	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN8@stoi
  000b8	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  000bd	58		 pop	 eax
  000be	5a		 pop	 edx
  000bf	5f		 pop	 edi
  000c0	5e		 pop	 esi
  000c1	5b		 pop	 ebx
  000c2	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  000c5	33 cd		 xor	 ecx, ebp
  000c7	e8 00 00 00 00	 call	 @__security_check_cookie@4
  000cc	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000d2	3b ec		 cmp	 ebp, esp
  000d4	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d9	8b e5		 mov	 esp, ebp
  000db	5d		 pop	 ebp
  000dc	c3		 ret	 0
  000dd	0f 1f 00	 npad	 3
$LN8@stoi:
  000e0	01 00 00 00	 DD	 1
  000e4	00 00 00 00	 DD	 $LN7@stoi
$LN7@stoi:
  000e8	dc ff ff ff	 DD	 -36			; ffffffdcH
  000ec	04 00 00 00	 DD	 4
  000f0	00 00 00 00	 DD	 $LN6@stoi
$LN6@stoi:
  000f4	5f		 DB	 95			; 0000005fH
  000f5	45		 DB	 69			; 00000045H
  000f6	70		 DB	 112			; 00000070H
  000f7	74		 DB	 116			; 00000074H
  000f8	72		 DB	 114			; 00000072H
  000f9	00		 DB	 0
?stoi@std@@YAHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PAIH@Z ENDP ; std::stoi
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	e8 00 00 00 00	 call	 ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 1383 :     constexpr _Ty1& _Get_first() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1384 :         return *this;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]

; 1385 :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal, COMDAT
; _this$ = ecx

; 5032 :     _CONSTEXPR20 _Alty& _Getal() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5033 :         return _Mypair._Get_first();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first

; 5034 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
_TEXT	SEGMENT
$T2 = -257						; size = 1
__Al$3 = -56						; size = 4
__Ptr$4 = -44						; size = 4
__My_data$ = -32					; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT
; _this$ = ecx

; 5004 :     _CONSTEXPR20 void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec fc 00 00
	00		 sub	 esp, 252		; 000000fcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d 7d b8	 lea	 edi, DWORD PTR [ebp-72]
  0001e	b9 0f 00 00 00	 mov	 ecx, 15			; 0000000fH
  00023	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00028	f3 ab		 rep stosd
  0002a	59		 pop	 ecx
  0002b	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00030	33 c5		 xor	 eax, ebp
  00032	50		 push	 eax
  00033	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00036	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003c	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx
  0003f	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00044	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 5005 :         auto& _My_data = _Mypair._Myval2;

  00049	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  0004c	89 45 e0	 mov	 DWORD PTR __My_data$[ebp], eax

; 5006 :         _My_data._Orphan_all();

  0004f	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  00052	e8 00 00 00 00	 call	 ?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 5007 :         _ASAN_STRING_REMOVE(*this);
; 5008 :         if (_My_data._Large_string_engaged()) {

  00057	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0005a	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0005f	0f b6 c0	 movzx	 eax, al
  00062	85 c0		 test	 eax, eax
  00064	74 41		 je	 SHORT $LN2@Tidy_deall

; 5009 :             const pointer _Ptr = _My_data._Bx._Ptr;

  00066	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00069	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0006c	89 4d d4	 mov	 DWORD PTR __Ptr$4[ebp], ecx

; 5010 :             auto& _Al          = _Getal();

  0006f	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00072	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00077	89 45 c8	 mov	 DWORD PTR __Al$3[ebp], eax

; 5011 :             _Destroy_in_place(_My_data._Bx._Ptr);

  0007a	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  0007d	83 c0 04	 add	 eax, 4
  00080	50		 push	 eax
  00081	e8 00 00 00 00	 call	 ??$_Destroy_in_place@PAD@std@@YAXAAPAD@Z ; std::_Destroy_in_place<char *>
  00086	83 c4 04	 add	 esp, 4

; 5012 :             _My_data._Activate_SSO_buffer();

  00089	8b 4d e0	 mov	 ecx, DWORD PTR __My_data$[ebp]
  0008c	e8 00 00 00 00	 call	 ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer

; 5013 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

  00091	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  00094	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00097	83 c1 01	 add	 ecx, 1
  0009a	51		 push	 ecx
  0009b	8b 55 d4	 mov	 edx, DWORD PTR __Ptr$4[ebp]
  0009e	52		 push	 edx
  0009f	8b 4d c8	 mov	 ecx, DWORD PTR __Al$3[ebp]
  000a2	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QAEXQADI@Z ; std::allocator<char>::deallocate
$LN2@Tidy_deall:

; 5014 :         }
; 5015 : 
; 5016 :         _My_data._Mysize = 0;

  000a7	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  000aa	c7 40 14 00 00
	00 00		 mov	 DWORD PTR [eax+20], 0

; 5017 :         _My_data._Myres  = _BUF_SIZE - 1;

  000b1	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  000b4	c7 40 18 0f 00
	00 00		 mov	 DWORD PTR [eax+24], 15	; 0000000fH

; 5018 :         // the _Traits::assign is last so the codegen doesn't think the char write can alias this
; 5019 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());

  000bb	c6 85 ff fe ff
	ff 00		 mov	 BYTE PTR $T2[ebp], 0
  000c2	8d 85 ff fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  000c8	50		 push	 eax
  000c9	b9 01 00 00 00	 mov	 ecx, 1
  000ce	6b d1 00	 imul	 edx, ecx, 0
  000d1	8b 45 e0	 mov	 eax, DWORD PTR __My_data$[ebp]
  000d4	8d 4c 10 04	 lea	 ecx, DWORD PTR [eax+edx+4]
  000d8	51		 push	 ecx
  000d9	e8 00 00 00 00	 call	 ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ; std::_Narrow_char_traits<char,int>::assign
  000de	83 c4 08	 add	 esp, 8

; 5020 :     }

  000e1	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000e4	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000eb	59		 pop	 ecx
  000ec	5f		 pop	 edi
  000ed	5e		 pop	 esi
  000ee	5b		 pop	 ebx
  000ef	81 c4 08 01 00
	00		 add	 esp, 264		; 00000108H
  000f5	3b ec		 cmp	 ebp, esp
  000f7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000fc	8b e5		 mov	 esp, ebp
  000fe	5d		 pop	 ebp
  000ff	c3		 ret	 0
  00100	cc		 int	 3
  00101	cc		 int	 3
  00102	cc		 int	 3
  00103	cc		 int	 3
  00104	cc		 int	 3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ:
  00000	90		 npad	 1
  00001	90		 npad	 1
  00002	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00006	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00009	8b 8a f4 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-268]
  0000f	33 c8		 xor	 ecx, eax
  00011	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00016	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ
  0001b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 4255 :     _NODISCARD _CONSTEXPR20 _Ret_z_ const _Elem* c_str() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 4256 :         return _Mypair._Myval2._Myptr();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr

; 4257 :     }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
__To_delete$ = -48					; size = 4
_$S4$ = -33						; size = 1
__Alproxy$ = -24					; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 3267 :     _CONSTEXPR20 ~basic_string() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d cc	 lea	 edi, DWORD PTR [ebp-52]
  00010	b9 0d 00 00 00	 mov	 ecx, 13			; 0000000dH
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 3268 :         _Tidy_deallocate();

  00034	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	e8 00 00 00 00	 call	 ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate

; 3269 : #if _ITERATOR_DEBUG_LEVEL != 0
; 3270 :         auto&& _Alproxy          = _GET_PROXY_ALLOCATOR(_Alty, _Getal());

  0003c	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0003f	e8 00 00 00 00	 call	 ?_Getal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEAAV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Getal
  00044	50		 push	 eax
  00045	8d 4d df	 lea	 ecx, DWORD PTR _$S4$[ebp]
  00048	e8 00 00 00 00	 call	 ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
  0004d	8d 45 df	 lea	 eax, DWORD PTR _$S4$[ebp]
  00050	89 45 e8	 mov	 DWORD PTR __Alproxy$[ebp], eax

; 3271 :         const auto _To_delete    = _Mypair._Myval2._Myproxy;

  00053	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  00056	8b 08		 mov	 ecx, DWORD PTR [eax]
  00058	89 4d d0	 mov	 DWORD PTR __To_delete$[ebp], ecx

; 3272 :         _Mypair._Myval2._Myproxy = nullptr;

  0005b	8b 45 f4	 mov	 eax, DWORD PTR _this$[ebp]
  0005e	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 3273 :         _Delete_plain_internal(_Alproxy, _To_delete);

  00064	8b 45 d0	 mov	 eax, DWORD PTR __To_delete$[ebp]
  00067	50		 push	 eax
  00068	8b 4d e8	 mov	 ecx, DWORD PTR __Alproxy$[ebp]
  0006b	51		 push	 ecx
  0006c	e8 00 00 00 00	 call	 ??$_Delete_plain_internal@V?$allocator@U_Container_proxy@std@@@std@@@std@@YAXAAV?$allocator@U_Container_proxy@std@@@0@QAU_Container_proxy@0@@Z ; std::_Delete_plain_internal<std::allocator<std::_Container_proxy> >
  00071	83 c4 08	 add	 esp, 8

; 3274 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 3275 :     }

  00074	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00077	e8 00 00 00 00	 call	 ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
  0007c	52		 push	 edx
  0007d	8b cd		 mov	 ecx, ebp
  0007f	50		 push	 eax
  00080	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@basic_stri
  00086	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  0008b	58		 pop	 eax
  0008c	5a		 pop	 edx
  0008d	5f		 pop	 edi
  0008e	5e		 pop	 esi
  0008f	5b		 pop	 ebx
  00090	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00093	33 cd		 xor	 ecx, ebp
  00095	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0009a	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000a0	3b ec		 cmp	 ebp, esp
  000a2	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c3		 ret	 0
  000ab	90		 npad	 1
$LN5@basic_stri:
  000ac	01 00 00 00	 DD	 1
  000b0	00 00 00 00	 DD	 $LN4@basic_stri
$LN4@basic_stri:
  000b4	df ff ff ff	 DD	 -33			; ffffffdfH
  000b8	01 00 00 00	 DD	 1
  000bc	00 00 00 00	 DD	 $LN3@basic_stri
$LN3@basic_stri:
  000c0	24		 DB	 36			; 00000024H
  000c1	53		 DB	 83			; 00000053H
  000c2	34		 DB	 52			; 00000034H
  000c3	00		 DB	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00023	83 c1 04	 add	 ecx, 4
  00026	e8 00 00 00 00	 call	 ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 2341 :         _CONSTEXPR20 ~_Bxty() noexcept {} // user-provided, for fancy pointers

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer, COMDAT
; _this$ = ecx

; 2304 :     constexpr void _Activate_SSO_buffer() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2305 :         // begin the lifetime of the array elements (e.g., before copying into them)
; 2306 : #if _HAS_CXX20
; 2307 :         if (_STD is_constant_evaluated()) {
; 2308 :             for (size_type _Idx = 0; _Idx < _BUF_SIZE; ++_Idx) {
; 2309 :                 _Bx._Buf[_Idx] = value_type();
; 2310 :             }
; 2311 :         }
; 2312 : #endif // _HAS_CXX20
; 2313 :     }

  0002a	5f		 pop	 edi
  0002b	5e		 pop	 esi
  0002c	5b		 pop	 ebx
  0002d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00033	3b ec		 cmp	 ebp, esp
  00035	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
?_Activate_SSO_buffer@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Activate_SSO_buffer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
tv66 = -208						; size = 4
_this$ = -8						; size = 4
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT
; _this$ = ecx

; 2300 :     _CONSTEXPR20 bool _Large_string_engaged() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f0	 lea	 edi, DWORD PTR [ebp-16]
  00010	b9 04 00 00 00	 mov	 ecx, 4
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2301 :         return _BUF_SIZE <= _Myres;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 78 18 10	 cmp	 DWORD PTR [eax+24], 16	; 00000010H
  00031	72 0c		 jb	 SHORT $LN3@Large_stri
  00033	c7 85 30 ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv66[ebp], 1
  0003d	eb 0a		 jmp	 SHORT $LN4@Large_stri
$LN3@Large_stri:
  0003f	c7 85 30 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv66[ebp], 0
$LN4@Large_stri:
  00049	8a 85 30 ff ff
	ff		 mov	 al, BYTE PTR tv66[ebp]

; 2302 :     }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
__Result$ = -20						; size = 4
_this$ = -8						; size = 4
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 2291 :     _CONSTEXPR20 const value_type* _Myptr() const noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e8	 lea	 edi, DWORD PTR [ebp-24]
  00010	b9 06 00 00 00	 mov	 ecx, 6
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 2292 :         const value_type* _Result = _Bx._Buf;

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 c0 04	 add	 eax, 4
  00030	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax

; 2293 :         if (_Large_string_engaged()) {

  00033	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00036	e8 00 00 00 00	 call	 ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QBE_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
  0003b	0f b6 c0	 movzx	 eax, al
  0003e	85 c0		 test	 eax, eax
  00040	74 12		 je	 SHORT $LN2@Myptr

; 2294 :             _Result = _Unfancy(_Bx._Ptr);

  00042	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00048	51		 push	 ecx
  00049	e8 00 00 00 00	 call	 ??$_Unfancy@D@std@@YAPADPAD@Z ; std::_Unfancy<char>
  0004e	83 c4 04	 add	 esp, 4
  00051	89 45 ec	 mov	 DWORD PTR __Result$[ebp], eax
$LN2@Myptr:

; 2295 :         }
; 2296 : 
; 2297 :         return _Result;

  00054	8b 45 ec	 mov	 eax, DWORD PTR __Result$[ebp]

; 2298 :     }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00060	3b ec		 cmp	 ebp, esp
  00062	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00067	8b e5		 mov	 esp, ebp
  00069	5d		 pop	 ebp
  0006a	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXQADI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXQADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 827  :     _CONSTEXPR20 void deallocate(_Ty* const _Ptr, const size_t _Count) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
$LN4@deallocate:

; 828  :         _STL_ASSERT(_Ptr != nullptr || _Count == 0, "null pointer cannot point to a block of non-zero size");

  0002a	83 7d 08 00	 cmp	 DWORD PTR __Ptr$[ebp], 0
  0002e	75 06		 jne	 SHORT $LN10@deallocate
  00030	83 7d 0c 00	 cmp	 DWORD PTR __Count$[ebp], 0
  00034	75 02		 jne	 SHORT $LN7@deallocate
$LN10@deallocate:
  00036	eb 5c		 jmp	 SHORT $LN2@deallocate
$LN7@deallocate:
  00038	8b f4		 mov	 esi, esp
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0DG@KGHKKGBC@null?5pointer?5cannot?5point?5to?5a?5@
  0003f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  00044	6a 00		 push	 0
  00046	68 3c 03 00 00	 push	 828			; 0000033cH
  0004b	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@ONGHGEHM@C?3?2Program?5Files?2Microsoft?5Visu@
  00050	6a 02		 push	 2
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00058	83 c4 18	 add	 esp, 24			; 00000018H
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	83 f8 01	 cmp	 eax, 1
  00065	75 01		 jne	 SHORT $LN12@deallocate
  00067	cc		 int	 3
$LN12@deallocate:
  00068	8b f4		 mov	 esi, esp
  0006a	6a 00		 push	 0
  0006c	68 3c 03 00 00	 push	 828			; 0000033cH
  00071	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@DGNBIMPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  0007b	68 00 00 00 00	 push	 OFFSET ??_C@_1HA@FACCKGGH@?$AA?$CC?$AAn?$AAu?$AAl?$AAl?$AA?5?$AAp?$AAo?$AAi?$AAn?$AAt?$AAe?$AAr?$AA?5?$AAc@
  00080	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  00086	83 c4 14	 add	 esp, 20			; 00000014H
  00089	3b f4		 cmp	 esi, esp
  0008b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00090	33 c0		 xor	 eax, eax
  00092	75 a4		 jne	 SHORT $LN7@deallocate
$LN2@deallocate:
  00094	33 c0		 xor	 eax, eax
  00096	75 92		 jne	 SHORT $LN4@deallocate

; 829  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 830  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

  00098	8b 45 0c	 mov	 eax, DWORD PTR __Count$[ebp]
  0009b	50		 push	 eax
  0009c	8b 4d 08	 mov	 ecx, DWORD PTR __Ptr$[ebp]
  0009f	51		 push	 ecx
  000a0	e8 00 00 00 00	 call	 ??$_Deallocate@$07$0A@@std@@YAXPAXI@Z ; std::_Deallocate<8,0>
  000a5	83 c4 08	 add	 esp, 8

; 831  :     }

  000a8	5f		 pop	 edi
  000a9	5e		 pop	 esi
  000aa	5b		 pop	 ebx
  000ab	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  000b1	3b ec		 cmp	 ebp, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	8b e5		 mov	 esp, ebp
  000ba	5d		 pop	 ebp
  000bb	c2 08 00	 ret	 8
?deallocate@?$allocator@D@std@@QAEXQADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?eof@?$_Narrow_char_traits@DH@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ PROC		; std::_Narrow_char_traits<char,int>::eof, COMDAT

; 488  :     _NODISCARD static constexpr int_type eof() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 489  :         return static_cast<int_type>(EOF);

  00021	83 c8 ff	 or	 eax, -1

; 490  :     }

  00024	5f		 pop	 edi
  00025	5e		 pop	 esi
  00026	5b		 pop	 ebx
  00027	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002d	3b ec		 cmp	 ebp, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
?eof@?$_Narrow_char_traits@DH@std@@SAHXZ ENDP		; std::_Narrow_char_traits<char,int>::eof
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z
_TEXT	SEGMENT
tv65 = -196						; size = 4
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z PROC ; std::_Narrow_char_traits<char,int>::eq_int_type, COMDAT

; 480  :     _NODISCARD static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d fc	 lea	 edi, DWORD PTR [ebp-4]
  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 481  :         return _Left == _Right;

  00025	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00028	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  0002b	8b 10		 mov	 edx, DWORD PTR [eax]
  0002d	3b 11		 cmp	 edx, DWORD PTR [ecx]
  0002f	75 0c		 jne	 SHORT $LN3@eq_int_typ
  00031	c7 85 3c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv65[ebp], 1
  0003b	eb 0a		 jmp	 SHORT $LN4@eq_int_typ
$LN3@eq_int_typ:
  0003d	c7 85 3c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv65[ebp], 0
$LN4@eq_int_typ:
  00047	8a 85 3c ff ff
	ff		 mov	 al, BYTE PTR tv65[ebp]

; 482  :     }

  0004d	5f		 pop	 edi
  0004e	5e		 pop	 esi
  0004f	5b		 pop	 ebx
  00050	81 c4 c4 00 00
	00		 add	 esp, 196		; 000000c4H
  00056	3b ec		 cmp	 ebp, esp
  00058	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
?eq_int_type@?$_Narrow_char_traits@DH@std@@SA_NABH0@Z ENDP ; std::_Narrow_char_traits<char,int>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z PROC	; std::_Narrow_char_traits<char,int>::assign, COMDAT

; 455  :     static _CONSTEXPR17 void assign(_Elem& _Left, const _Elem& _Right) noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 456  : #if _HAS_CXX20
; 457  :         if (_STD is_constant_evaluated()) {
; 458  :             return _Primary_char_traits::assign(_Left, _Right);
; 459  :         }
; 460  : #endif // _HAS_CXX20
; 461  :         _Left = _Right;

  00021	8b 45 08	 mov	 eax, DWORD PTR __Left$[ebp]
  00024	8b 4d 0c	 mov	 ecx, DWORD PTR __Right$[ebp]
  00027	8a 11		 mov	 dl, BYTE PTR [ecx]
  00029	88 10		 mov	 BYTE PTR [eax], dl

; 462  :     }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
?assign@?$_Narrow_char_traits@DH@std@@SAXAADABD@Z ENDP	; std::_Narrow_char_traits<char,int>::assign
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xstring
;	COMDAT ?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z PROC	; std::_Narrow_char_traits<char,int>::length, COMDAT

; 402  :     _NODISCARD static _CONSTEXPR17 size_t length(_In_z_ const _Elem* const _First) noexcept /* strengthened */ {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __B71DB0E4_xstring
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 403  :         // find length of null-terminated string
; 404  : #if _HAS_CXX17
; 405  : #ifdef __cpp_char8_t
; 406  :         if constexpr (is_same_v<_Elem, char8_t>) {
; 407  : #if _HAS_U8_INTRINSICS
; 408  :             return __builtin_u8strlen(_First);
; 409  : #else // ^^^ use u8 intrinsics / no u8 intrinsics vvv
; 410  :             return _Primary_char_traits::length(_First);
; 411  : #endif // _HAS_U8_INTRINSICS
; 412  :         } else
; 413  : #endif // __cpp_char8_t
; 414  :         {
; 415  :             return __builtin_strlen(_First);
; 416  :         }
; 417  : #else // _HAS_CXX17
; 418  :         return _CSTD strlen(reinterpret_cast<const char*>(_First));

  00021	8b 45 08	 mov	 eax, DWORD PTR __First$[ebp]
  00024	50		 push	 eax
  00025	e8 00 00 00 00	 call	 _strlen
  0002a	83 c4 04	 add	 esp, 4

; 419  : #endif // _HAS_CXX17
; 420  :     }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
?length@?$_Narrow_char_traits@DH@std@@SAIQBD@Z ENDP	; std::_Narrow_char_traits<char,int>::length
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\utility
;	COMDAT ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z
_TEXT	SEGMENT
__Old_val$ = -8						; size = 4
__Val$ = 8						; size = 4
__New_val$ = 12						; size = 4
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z PROC ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>, COMDAT

; 651  :     conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  0000f	b9 03 00 00 00	 mov	 ecx, 3
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __A95B55BB_utility
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 652  :     // assign _New_val to _Val, return previous _Val
; 653  :     _Ty _Old_val = static_cast<_Ty&&>(_Val);

  00025	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	89 4d f8	 mov	 DWORD PTR __Old_val$[ebp], ecx

; 654  :     _Val         = static_cast<_Other&&>(_New_val);

  0002d	8b 45 08	 mov	 eax, DWORD PTR __Val$[ebp]
  00030	8b 4d 0c	 mov	 ecx, DWORD PTR __New_val$[ebp]
  00033	8b 11		 mov	 edx, DWORD PTR [ecx]
  00035	89 10		 mov	 DWORD PTR [eax], edx

; 655  :     return _Old_val;

  00037	8b 45 f8	 mov	 eax, DWORD PTR __Old_val$[ebp]

; 656  : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ENDP ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
__Lock$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_locked_v3, COMDAT
; _this$ = ecx

; 1086 :     void _Orphan_all_locked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d e4	 lea	 edi, DWORD PTR [ebp-28]
  00010	b9 07 00 00 00	 mov	 ecx, 7
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00022	33 c5		 xor	 eax, ebp
  00024	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00027	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx
  0002a	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  0002f	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1087 :         _Lockit _Lock(_LOCK_DEBUG);

  00034	8b f4		 mov	 esi, esp
  00036	6a 03		 push	 3
  00038	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  0003b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
  00041	3b f4		 cmp	 esi, esp
  00043	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 1088 :         _Orphan_all_unlocked_v3();

  00048	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  0004b	e8 00 00 00 00	 call	 ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_unlocked_v3

; 1089 :     }

  00050	8b f4		 mov	 esi, esp
  00052	8d 4d e8	 lea	 ecx, DWORD PTR __Lock$[ebp]
  00055	ff 15 00 00 00
	00		 call	 DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00062	52		 push	 edx
  00063	8b cd		 mov	 ecx, ebp
  00065	50		 push	 eax
  00066	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN5@Orphan_all
  0006c	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00071	58		 pop	 eax
  00072	5a		 pop	 edx
  00073	5f		 pop	 edi
  00074	5e		 pop	 esi
  00075	5b		 pop	 ebx
  00076	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00079	33 cd		 xor	 ecx, ebp
  0007b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00080	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  00086	3b ec		 cmp	 ebp, esp
  00088	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008d	8b e5		 mov	 esp, ebp
  0008f	5d		 pop	 ebp
  00090	c3		 ret	 0
  00091	0f 1f 00	 npad	 3
$LN5@Orphan_all:
  00094	01 00 00 00	 DD	 1
  00098	00 00 00 00	 DD	 $LN4@Orphan_all
$LN4@Orphan_all:
  0009c	e8 ff ff ff	 DD	 -24			; ffffffe8H
  000a0	04 00 00 00	 DD	 4
  000a4	00 00 00 00	 DD	 $LN3@Orphan_all
$LN3@Orphan_all:
  000a8	5f		 DB	 95			; 0000005fH
  000a9	4c		 DB	 76			; 0000004cH
  000aa	6f		 DB	 111			; 0000006fH
  000ab	63		 DB	 99			; 00000063H
  000ac	6b		 DB	 107			; 0000006bH
  000ad	00		 DB	 0
?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_locked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ
_TEXT	SEGMENT
$T1 = -224						; size = 4
__Pnext$2 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ PROC ; std::_Container_base12::_Orphan_all_unlocked_v3, COMDAT
; _this$ = ecx

; 1226 : _CONSTEXPR20 void _Container_base12::_Orphan_all_unlocked_v3() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec e4 00 00
	00		 sub	 esp, 228		; 000000e4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d dc	 lea	 edi, DWORD PTR [ebp-36]
  00010	b9 09 00 00 00	 mov	 ecx, 9
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1227 :     if (!_Myproxy) { // no proxy, already done

  0002a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002d	83 38 00	 cmp	 DWORD PTR [eax], 0
  00030	75 02		 jne	 SHORT $LN5@Orphan_all

; 1228 :         return;

  00032	eb 41		 jmp	 SHORT $LN6@Orphan_all
$LN5@Orphan_all:

; 1229 :     }
; 1230 : 
; 1231 :     // proxy allocated, drain it
; 1232 :     for (auto _Pnext = _STD exchange(_Myproxy->_Myfirstiter, nullptr); _Pnext; _Pnext = _Pnext->_Mynextiter) {

  00034	c7 85 20 ff ff
	ff 00 00 00 00	 mov	 DWORD PTR $T1[ebp], 0
  0003e	8d 85 20 ff ff
	ff		 lea	 eax, DWORD PTR $T1[ebp]
  00044	50		 push	 eax
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	83 c2 04	 add	 edx, 4
  0004d	52		 push	 edx
  0004e	e8 00 00 00 00	 call	 ??$exchange@PAU_Iterator_base12@std@@$$T@std@@YAPAU_Iterator_base12@0@AAPAU10@$$QA$$T@Z ; std::exchange<std::_Iterator_base12 *,std::nullptr_t>
  00053	83 c4 08	 add	 esp, 8
  00056	89 45 ec	 mov	 DWORD PTR __Pnext$2[ebp], eax
  00059	eb 09		 jmp	 SHORT $LN4@Orphan_all
$LN2@Orphan_all:
  0005b	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0005e	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00061	89 4d ec	 mov	 DWORD PTR __Pnext$2[ebp], ecx
$LN4@Orphan_all:
  00064	83 7d ec 00	 cmp	 DWORD PTR __Pnext$2[ebp], 0
  00068	74 0b		 je	 SHORT $LN6@Orphan_all

; 1233 :         _Pnext->_Myproxy = nullptr;

  0006a	8b 45 ec	 mov	 eax, DWORD PTR __Pnext$2[ebp]
  0006d	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 1234 :     }

  00073	eb e6		 jmp	 SHORT $LN2@Orphan_all
$LN6@Orphan_all:

; 1235 : }

  00075	5f		 pop	 edi
  00076	5e		 pop	 esi
  00077	5b		 pop	 ebx
  00078	81 c4 e4 00 00
	00		 add	 esp, 228		; 000000e4H
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
?_Orphan_all_unlocked_v3@_Container_base12@std@@AAEXXZ ENDP ; std::_Container_base12::_Orphan_all_unlocked_v3
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 1237 : _CONSTEXPR20 void _Container_base12::_Orphan_all() noexcept {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d 7d f4	 lea	 edi, DWORD PTR [ebp-12]
  00010	b9 03 00 00 00	 mov	 ecx, 3
  00015	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001a	f3 ab		 rep stosd
  0001c	59		 pop	 ecx
  0001d	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00020	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  00025	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 1238 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1239 : #if _HAS_CXX20
; 1240 :     if (_STD is_constant_evaluated()) {
; 1241 :         _Orphan_all_unlocked_v3();
; 1242 :     } else
; 1243 : #endif // _HAS_CXX20
; 1244 :     {
; 1245 :         _Orphan_all_locked_v3();

  0002a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002d	e8 00 00 00 00	 call	 ?_Orphan_all_locked_v3@_Container_base12@std@@AAEXXZ ; std::_Container_base12::_Orphan_all_locked_v3

; 1246 :     }
; 1247 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1248 : }

  00032	5f		 pop	 edi
  00033	5e		 pop	 esi
  00034	5b		 pop	 ebx
  00035	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003b	3b ec		 cmp	 ebp, esp
  0003d	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Tools\MSVC\14.34.31933\include\xmemory
;	COMDAT ?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z
_TEXT	SEGMENT
__Back_shift$ = -44					; size = 4
__Min_back_shift$ = -32					; size = 4
__Ptr_container$ = -20					; size = 4
__Ptr_user$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Bytes$ = 12						; size = 4
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z PROC ; std::_Adjust_manually_vector_aligned, COMDAT

; 145  : inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f0 00 00
	00		 sub	 esp, 240		; 000000f0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d 7d d0	 lea	 edi, DWORD PTR [ebp-48]
  0000f	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00014	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00019	f3 ab		 rep stosd
  0001b	b9 00 00 00 00	 mov	 ecx, OFFSET __C3CE3678_xmemory
  00020	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4

; 146  :     // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
; 147  :     _Bytes += _Non_user_size;

  00025	8b 45 0c	 mov	 eax, DWORD PTR __Bytes$[ebp]
  00028	8b 08		 mov	 ecx, DWORD PTR [eax]
  0002a	83 c1 27	 add	 ecx, 39			; 00000027H
  0002d	8b 55 0c	 mov	 edx, DWORD PTR __Bytes$[ebp]
  00030	89 0a		 mov	 DWORD PTR [edx], ecx

; 148  : 
; 149  :     const uintptr_t* const _Ptr_user = static_cast<uintptr_t*>(_Ptr);

  00032	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00035	8b 08		 mov	 ecx, DWORD PTR [eax]
  00037	89 4d f8	 mov	 DWORD PTR __Ptr_user$[ebp], ecx

; 150  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

  0003a	b8 04 00 00 00	 mov	 eax, 4
  0003f	6b c8 ff	 imul	 ecx, eax, -1
  00042	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00045	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  00048	89 45 ec	 mov	 DWORD PTR __Ptr_container$[ebp], eax
$LN4@Adjust_man:

; 151  : 
; 152  :     // If the following asserts, it likely means that we are performing
; 153  :     // an aligned delete on memory coming from an unaligned allocation.
; 154  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");

  0004b	b8 04 00 00 00	 mov	 eax, 4
  00050	6b c8 fe	 imul	 ecx, eax, -2
  00053	8b 55 f8	 mov	 edx, DWORD PTR __Ptr_user$[ebp]
  00056	81 3c 0a fa fa
	fa fa		 cmp	 DWORD PTR [edx+ecx], -84215046 ; fafafafaH
  0005d	75 02		 jne	 SHORT $LN7@Adjust_man
  0005f	eb 64		 jmp	 SHORT $LN2@Adjust_man
$LN7@Adjust_man:
  00061	8b f4		 mov	 esi, esp
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  00068	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  0006d	6a 00		 push	 0
  0006f	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  00074	83 c0 09	 add	 eax, 9
  00077	50		 push	 eax
  00078	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@ONGHGEHM@C?3?2Program?5Files?2Microsoft?5Visu@
  0007d	6a 02		 push	 2
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  00085	83 c4 18	 add	 esp, 24			; 00000018H
  00088	3b f4		 cmp	 esi, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	83 f8 01	 cmp	 eax, 1
  00092	75 01		 jne	 SHORT $LN19@Adjust_man
  00094	cc		 int	 3
$LN19@Adjust_man:
  00095	8b f4		 mov	 esi, esp
  00097	6a 00		 push	 0
  00099	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  0009e	83 c0 09	 add	 eax, 9
  000a1	50		 push	 eax
  000a2	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@DGNBIMPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  000a7	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  000ac	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  000b1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  000b7	83 c4 14	 add	 esp, 20			; 00000014H
  000ba	3b f4		 cmp	 esi, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	33 c0		 xor	 eax, eax
  000c3	75 9c		 jne	 SHORT $LN7@Adjust_man
$LN2@Adjust_man:
  000c5	33 c0		 xor	 eax, eax
  000c7	75 82		 jne	 SHORT $LN4@Adjust_man

; 155  : 
; 156  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 157  :     // in range [_Min_back_shift, _Non_user_size]
; 158  : #ifdef _DEBUG
; 159  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);

  000c9	c7 45 e0 08 00
	00 00		 mov	 DWORD PTR __Min_back_shift$[ebp], 8

; 160  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 161  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 162  : #endif // _DEBUG
; 163  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

  000d0	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	2b 4d ec	 sub	 ecx, DWORD PTR __Ptr_container$[ebp]
  000d8	89 4d d4	 mov	 DWORD PTR __Back_shift$[ebp], ecx
$LN10@Adjust_man:

; 164  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

  000db	83 7d d4 08	 cmp	 DWORD PTR __Back_shift$[ebp], 8
  000df	72 08		 jb	 SHORT $LN13@Adjust_man
  000e1	83 7d d4 27	 cmp	 DWORD PTR __Back_shift$[ebp], 39 ; 00000027H
  000e5	77 02		 ja	 SHORT $LN13@Adjust_man
  000e7	eb 64		 jmp	 SHORT $LN8@Adjust_man
$LN13@Adjust_man:
  000e9	8b f4		 mov	 esi, esp
  000eb	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@FCMFBGOM@invalid?5argument@
  000f0	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs@
  000f5	6a 00		 push	 0
  000f7	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  000fc	83 c0 13	 add	 eax, 19			; 00000013H
  000ff	50		 push	 eax
  00100	68 00 00 00 00	 push	 OFFSET ??_C@_0GC@ONGHGEHM@C?3?2Program?5Files?2Microsoft?5Visu@
  00105	6a 02		 push	 2
  00107	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReport
  0010d	83 c4 18	 add	 esp, 24			; 00000018H
  00110	3b f4		 cmp	 esi, esp
  00112	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00117	83 f8 01	 cmp	 eax, 1
  0011a	75 01		 jne	 SHORT $LN20@Adjust_man
  0011c	cc		 int	 3
$LN20@Adjust_man:
  0011d	8b f4		 mov	 esi, esp
  0011f	6a 00		 push	 0
  00121	a1 00 00 00 00	 mov	 eax, DWORD PTR ?__LINE__Var@?0??_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z@4JA
  00126	83 c0 13	 add	 eax, 19			; 00000013H
  00129	50		 push	 eax
  0012a	68 00 00 00 00	 push	 OFFSET ??_C@_1ME@DGNBIMPE@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe@
  0012f	68 00 00 00 00	 push	 OFFSET ??_C@_11LOCGONAA@@
  00134	68 00 00 00 00	 push	 OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe@
  00139	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___invalid_parameter
  0013f	83 c4 14	 add	 esp, 20			; 00000014H
  00142	3b f4		 cmp	 esi, esp
  00144	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00149	33 c0		 xor	 eax, eax
  0014b	75 9c		 jne	 SHORT $LN13@Adjust_man
$LN8@Adjust_man:
  0014d	33 c0		 xor	 eax, eax
  0014f	75 8a		 jne	 SHORT $LN10@Adjust_man

; 165  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

  00151	8b 45 08	 mov	 eax, DWORD PTR __Ptr$[ebp]
  00154	8b 4d ec	 mov	 ecx, DWORD PTR __Ptr_container$[ebp]
  00157	89 08		 mov	 DWORD PTR [eax], ecx

; 166  : }

  00159	5f		 pop	 edi
  0015a	5e		 pop	 esi
  0015b	5b		 pop	 ebx
  0015c	81 c4 f0 00 00
	00		 add	 esp, 240		; 000000f0H
  00162	3b ec		 cmp	 ebp, esp
  00164	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00169	8b e5		 mov	 esp, ebp
  0016b	5d		 pop	 ebp
  0016c	c3		 ret	 0
?_Adjust_manually_vector_aligned@std@@YAXAAPAXAAI@Z ENDP ; std::_Adjust_manually_vector_aligned
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\User\Desktop\Everythin' for BSTU\Narkevich\1-ый курс 2-ой семестр\Lab's\решения лбр\LBR_01\LBR_01\Exercise_1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2CE65518_Exercise_1@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File D:\User\Desktop\Everythin' for BSTU\Narkevich\1-ый курс 2-ой семестр\Lab's\решения лбр\LBR_01\LBR_01\Exercise_1.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8b fd		 mov	 edi, ebp
  0000e	33 c9		 xor	 ecx, ecx
  00010	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  00015	f3 ab		 rep stosd
  00017	b9 00 00 00 00	 mov	 ecx, OFFSET __2CE65518_Exercise_1@cpp
  0001c	e8 00 00 00 00	 call	 @__CheckForDebuggerJustMyCode@4
  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0002a	3b ec		 cmp	 ebp, esp
  0002c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00031	8b e5		 mov	 esp, ebp
  00033	5d		 pop	 ebp
  00034	c3		 ret	 0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
